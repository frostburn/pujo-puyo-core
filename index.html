<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    body {
      background-color: #223;
    }
  </style>
<script type="module">
import { MultiplayerGame, RED, GREEN, YELLOW, BLUE, PURPLE, WIDTH, LIFE_HEIGHT, GHOST_Y, MOVES, GARBAGE, CONNECTS_DOWN, CONNECTS_UP, CONNECTS_RIGHT, CONNECTS_LEFT, combinedGarbageDisplay, maxDropletStrategy1 } from "./build/index.js";

// TODO: Tweak timings
// TODO: Responsive layout

const FRAME_RATE = 15;

// 'RGYBPN'
const STROKES = ["#d22", "#2d2", "#dd2", "#22e", "#d2c", "rgba(20, 160, 160, 0.88)"];
const FILLS = ["#922", "#292", "#882", "#229", "#828", "rgba(30, 255, 255, 0.94)"];
const STROKE_WIDTH = 0.15;
const SCREEN_STROKE = "#101";
const SCREEN_FILL = "rgba(0, 0, 0, 0.1)";

const LEFT_SCREEN_X = 1;
const LEFT_SCREEN_Y = 2;
const RIGHT_SCREEN_X = 10;
const RIGHT_SCREEN_Y = LEFT_SCREEN_Y;

const SVG_NS = "http://www.w3.org/2000/svg";

const game = new MultiplayerGame();

const container = document.createElement("div");

function svgElement(qualifiedName) {
  return document.createElementNS(SVG_NS, qualifiedName);
}

const ARC_SCALE_FLAGS = [true, true, false, false, false, true, true];
const ARC_TRANSLATION_FLAGS = [false, false, false, false, false, true, true];
/**
 * Transform <path> element's definition by first re-scaling it and then translating the points.
 * NOTE: Likely incomplete and pretty much untested.
 */
function transformPath(d, scale = 1, dx = 0, dy = 0) {
  const transformed = [];
  let scaleFlags = [];
  let translationFlags = [];
  let horizontal = true;
  d.split(/\s+/).forEach(token => {
    let num = parseFloat(token);
    if (isNaN(num)) {
      transformed.push(token);
      horizontal = true;
      if (token.toUpperCase() === "A") {
        scaleFlags = [...ARC_SCALE_FLAGS];
        translationFlags = [...ARC_TRANSLATION_FLAGS];
      } else if (token.toUpperCase() === "V") {
        horizontal = false;
      }
      if (token === token.toLowerCase()) {
        translationFlags = Array(7).fill(false);
      }
    } else {
      let scaleFlag = true;
      let translationFlag = true;
      if (scaleFlags.length) {
        scaleFlag = scaleFlags.shift();
      }
      if (translationFlags.length) {
        translationFlag = translationFlags.shift();
      }
      if (scaleFlag) {
        num *= scale;
      }
      if (translationFlag) {
        num += (horizontal ? dx : dy);
        horizontal = !horizontal;
      }
      transformed.push(num.toString());
    }
  });
  return transformed.join(" ");
}

const svg = svgElement("svg");
svg.setAttribute("width", "95vh");
svg.setAttribute("height", "95vh");
svg.setAttribute("viewBox", "0 0 19 19");

// Styles
const style = svgElement("style");
style.textContent = ".score-label {font: bold 0.7px sans-serif; fill:azure;} .score {font: bold 0.7px monospace; fill:azure;}";
svg.appendChild(style);

// Defs
const defs = svgElement("defs");

const screenDef = svgElement("g");
screenDef.setAttribute("id", "screen");

const mainScreen = svgElement("rect");
mainScreen.setAttribute("x", -0.1);
mainScreen.setAttribute("y", -0.1);
mainScreen.setAttribute("width", WIDTH + 0.2);
mainScreen.setAttribute("height", LIFE_HEIGHT + 0.2);
mainScreen.setAttribute("fill", SCREEN_FILL);
mainScreen.setAttribute("stroke", SCREEN_STROKE);
mainScreen.setAttribute("stroke-width", "0.11");
mainScreen.setAttribute("rx", "0.1");
mainScreen.setAttribute("ry", "0.1");
screenDef.appendChild(mainScreen);

const pieceBox = svgElement("path");
pieceBox.setAttribute("d",
  "M -0.1 0 " +
  "A 0.1 0.1 0 0 1 0 -0.1 " +
  "H 1 " +
  "A 0.1 0.1 0 0 1 1.1 0 " +
  "V 2 " +
  "A 0.1 0.1 0 0 0 1.2 2.1 " +
  "H 1.5 " +
  "A 0.1 0.1 0 0 1 1.6 2.2 " +
  "V 4.2 " +
  "A 0.1 0.1 0 0 1 1.5 4.3 " +
  "H 0.5 " +
  "A 0.1 0.1 0 0 1 0.4 4.2 " +
  "V 2.2 " +
  "A 0.1 0.1 0 0 0 0.3 2.1 " +
  "H 0 " +
  "A 0.1 0.1 0 0 1 -0.1 2 " +
  "Z"
);
pieceBox.setAttribute("fill", SCREEN_FILL);
pieceBox.setAttribute("stroke", SCREEN_STROKE);
pieceBox.setAttribute("stroke-width", "0.11");
pieceBox.setAttribute("transform", `translate(${WIDTH+0.5}, 0)`);
screenDef.appendChild(pieceBox);

defs.appendChild(screenDef);

const garbageDef = svgElement("circle");
garbageDef.setAttribute("id", "garbage");
garbageDef.setAttribute("r", 0.42);
defs.appendChild(garbageDef);

const sparksDef = svgElement("g");
sparksDef.setAttribute("id", "sparks");
for (let i = 0; i < 5; ++i) {
  const theta = 2 * Math.PI * i / 5;
  const spark = svgElement("circle");
  spark.setAttribute("cx", Math.cos(theta) * 0.3);
  spark.setAttribute("cy", Math.sin(theta) * 0.3);
  spark.setAttribute("r", 0.1);
  sparksDef.appendChild(spark);
}
const animation = svgElement("animateTransform");
animation.setAttribute("attributeName", "transform");
animation.setAttribute("type", "rotate");
animation.setAttribute("from", `0`);
animation.setAttribute("to", `360`);
animation.setAttribute("dur", "2s");
animation.setAttribute("repeatCount", "indefinite");
sparksDef.appendChild(animation);
defs.appendChild(sparksDef);

svg.appendChild(defs);

const heartDef = svgElement("path");
heartDef.setAttribute("id", "heart");
const heartD = "M 0 1 C 1.8 0 0 -1 0 0 C 0 -1 -1.8 0 0 1 Z";
heartDef.setAttribute("d", transformPath(heartD, 0.5, 0, -0.11));
defs.appendChild(heartDef);

const spadeDef = svgElement("path");
spadeDef.setAttribute("id", "spade");
const spadeD = (
  "M 0.3 0 " +
  "Q 0 0.6 0.5 0.8 " +
  "H -0.5 " +
  "Q 0 0.6 -0.3 0 " +
  "C -0.1 1 -1.8 0 0 -1 " +
  "C 1.8 0 0.1 1 0.3 0 " +
  "Z"
);
spadeDef.setAttribute("d", transformPath(spadeD, 0.45));
spadeDef.setAttribute("stroke-linejoin", "round");
defs.appendChild(spadeDef);

const moonDef = svgElement("path");
moonDef.setAttribute("id", "moon");
const moonD = "M 0 1 A 1.1 1.1 0 1 0 0 -1 A 1.04 1.04 0 0 1 0 1 Z";
moonDef.setAttribute("d", transformPath(moonD, 0.35, -0.25));
defs.appendChild(moonDef);

const diamondDef = svgElement("path");
diamondDef.setAttribute("id", "diamond");
const diamondD = "M 0 1 Q 0.55 0.55 1 0 Q 0.55 -0.55 0 -1 Q -0.55 -0.55 -1 0 Q -0.55 0.55 0 1 Z";
diamondDef.setAttribute("d", transformPath(diamondD, 0.4));
defs.appendChild(diamondDef);

const smallDef = svgElement("circle");
smallDef.setAttribute("id", "small");
smallDef.setAttribute("r", 0.2);
defs.appendChild(smallDef);

const largeDef = svgElement("circle");
largeDef.setAttribute("id", "large");
largeDef.setAttribute("r", 0.39);
defs.appendChild(largeDef);

const cometDef = svgElement("path");
cometDef.setAttribute("id", "comet");
const cometD = "M 0 1 A 1 1 0 0 1 0 -1 L 2 -1 L 0.5 -0.5 L 2.5 -0.1 L 0.3 0.3 L 1 1 Z";
cometDef.setAttribute("d", transformPath(cometD, 0.3, -0.15));
cometDef.setAttribute("transform", "rotate(-45)");
defs.appendChild(cometDef);

const starDef = svgElement("path");
starDef.setAttribute("id", "star");
let starD = "M 0 0.3";
const spikeDelta = Math.PI / 5;
for (let i = 1; i < 6; ++i) {
  const theta = 2 * Math.PI * i / 5;
  const x1 = 0.7 * Math.sin(theta - spikeDelta);
  const y1 = 0.7 * Math.cos(theta - spikeDelta);
  const x = 0.3 * Math.sin(theta);
  const y = 0.3 * Math.cos(theta);
  starD += ` Q ${x1} ${y1} ${x} ${y}`;
}
starD += " Z";
starDef.setAttribute("d", starD);
defs.appendChild(starDef);

const squareClip = svgElement("clipPath");
squareClip.setAttribute("id", "square");
const square = svgElement("rect");
square.setAttribute("x", -0.505);
square.setAttribute("y", -0.505);
square.setAttribute("width", 1.1);
square.setAttribute("height", 1.1);
squareClip.appendChild(square);
defs.appendChild(squareClip);

for (let i = 0; i < 16; ++i) {
  const connectedDef = svgElement("polygon");
  connectedDef.setAttribute("id", `panel${i}`);

  let points = [
    [0.4, 0.3],
    [0.3, 0.4]
  ];
  if (i & CONNECTS_DOWN) {
    points = points.concat([
      [0.3, 0.6],
      [0.4, 0.7],
      [-0.4, 0.7],
      [-0.3, 0.6],
    ]);
  }
  points = points.concat([
    [-0.3, 0.4],
    [-0.4, 0.3]
  ]);
  if (i & CONNECTS_LEFT) {
    points = points.concat([
      [-0.6, 0.3],
      [-0.7, 0.4],
      [-0.7, -0.4],
      [-0.6, -0.3]
    ]);
  }
  points = points.concat([
    [-0.4, -0.3],
    [-0.3, -0.4]
  ]);
  if (i & CONNECTS_UP) {
    points = points.concat([
      [-0.3, -0.6],
      [-0.4, -0.7],
      [0.4, -0.7],
      [0.3, -0.6],
    ]);
  }
  points = points.concat([
    [0.3, -0.4],
    [0.4, -0.3]
  ]);
  if (i & CONNECTS_RIGHT) {
    points = points.concat([
      [0.6, -0.3],
      [0.7, -0.4],
      [0.7, 0.4],
      [0.6, 0.3],
    ]);
  }

  connectedDef.setAttribute("points", points.map(pair => pair.join(",")).join(" "));

  connectedDef.setAttribute("clip-path", "url(#square)");

  defs.appendChild(connectedDef);
}

// Visible elements
const leftScreen = svgElement("use");
leftScreen.setAttribute("href", "#screen");
leftScreen.setAttribute("x", LEFT_SCREEN_X);
leftScreen.setAttribute("y", LEFT_SCREEN_Y);
svg.appendChild(leftScreen);

const rightScreen = svgElement("use");
rightScreen.setAttribute("href", "#screen");
rightScreen.setAttribute("x", RIGHT_SCREEN_X);
rightScreen.setAttribute("y", RIGHT_SCREEN_Y);
svg.appendChild(rightScreen);

const leftContent = svgElement("g");
leftContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftContent);

const rightContent = svgElement("g");
rightContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightContent);

const contents = [leftContent, rightContent];

container.appendChild(svg);
document.body.appendChild(container);

function panelAt(x, y, color, connectivity = 0) {
  const element = svgElement("use");
  if (color === GARBAGE) {
    element.setAttribute("href", "#garbage");
  } else {
    element.setAttribute("href", `#panel${connectivity}`);
  }
  element.setAttribute("x", x + 0.5);
  element.setAttribute("y", y + 0.5);
  element.setAttribute("fill", FILLS[color]);
  element.setAttribute("stroke", STROKES[color]);
  element.setAttribute("stroke-width", STROKE_WIDTH);
  if (color === GARBAGE) {
    return element;
  }
  const group = svgElement("g");
  group.appendChild(element);
  const glyph = svgElement("use");
  glyph.setAttribute("x", x + 0.5);
  glyph.setAttribute("y", y + 0.5);
  glyph.setAttribute("fill", STROKES[color]);
  glyph.setAttribute("transform-origin", `${x+0.5} ${y+0.5}`);
  let transform = "scale(0.6)";
  if (color === RED) {
    glyph.setAttribute("href", "#heart");
  } else if (color === GREEN) {
    glyph.setAttribute("href", "#large");
  } else if (color === YELLOW) {
    glyph.setAttribute("href", "#star");
    transform += " rotate(180)";
  } else if (color === BLUE) {
    glyph.setAttribute("href", "#moon");
    transform += " rotate(180)";
  } else if (color === PURPLE) {
    glyph.setAttribute("href", "#diamond");
  }
  glyph.setAttribute("transform", transform);
  group.appendChild(glyph);
  return group;
}

function renderGame() {
  leftContent.replaceChildren();
  rightContent.replaceChildren();

  const gameState = game.state;

  for (let i = 0; i < 2; ++i) {
    const garbageDisplay = combinedGarbageDisplay(gameState[i].pendingGarbage, gameState[i].lateGarbage);
    garbageDisplay.forEach((symbol, x) => {
      if (symbol === "rock") {
        symbol = "spade";
      } else if (symbol === "crown") {
        symbol = "diamond";
      }
      const glyph = svgElement("use");
      glyph.setAttribute("href", "#" + symbol);
      glyph.setAttribute("fill", FILLS[GARBAGE]);
      glyph.setAttribute("stroke", STROKES[GARBAGE]);
      glyph.setAttribute("stroke-width", STROKE_WIDTH);
      glyph.setAttribute("x", x + 0.5);
      glyph.setAttribute("y", -0.9);
      contents[i].appendChild(glyph);
    });

    const scoreLabel = svgElement("text");
    scoreLabel.setAttribute("y", LIFE_HEIGHT+0.8);
    scoreLabel.classList.add("score-label");
    scoreLabel.textContent = "Score:";
    contents[i].appendChild(scoreLabel);

    const score = svgElement("text");
    score.classList.add("score");
    score.setAttribute("y", LIFE_HEIGHT+0.8);
    score.setAttribute("dx", scoreLabel.getBBox().width + 0.1);
    score.textContent = gameState[i].score;
    contents[i].appendChild(score);

    const previewBag = gameState[i].visibleBag.slice(-4);
    contents[i].appendChild(panelAt(WIDTH + 0.5, 1, previewBag[0]));
    contents[i].appendChild(panelAt(WIDTH + 0.5, 0, previewBag[1]));
    contents[i].appendChild(panelAt(WIDTH + 1, 3.2, previewBag[2]));
    contents[i].appendChild(panelAt(WIDTH + 1, 2.2, previewBag[3]));

    for (let y = 0; y < LIFE_HEIGHT; ++y) {
      for (let x = 0; x < WIDTH; ++x) {
        const arrayIndex = x + (y + GHOST_Y + 1) * WIDTH;
        let index = gameState[i].screen.supported[arrayIndex];
        let falling = false;
        if (index < 0) {
          index = gameState[i].screen.unsupported[arrayIndex];
          falling = true;
        }
        if (index >= 0) {
          const panel = panelAt(x, y, index, gameState[i].screen.connectivity[arrayIndex]);
          if (falling) {
            const animation = svgElement("animateTransform");
            animation.setAttribute("attributeName", "transform");
            animation.setAttribute("attributeType", "XML");
            animation.setAttribute("type", "translate");
            animation.setAttribute("from", "0 0");
            animation.setAttribute("to", "0 1");
            animation.setAttribute("begin", `${svg.getCurrentTime()}s`);
            animation.setAttribute("dur", `${1/FRAME_RATE}s`);
            animation.setAttribute("repeatCount", 1);
            animation.setAttribute("fill", "freeze");

            panel.appendChild(animation);
          }

          contents[i].appendChild(panel);
        }

        index = gameState[i].screen.sparks[arrayIndex];
        if (index >= 0) {
          const sparks = svgElement("use");
          sparks.setAttribute("href", "#sparks");
          sparks.setAttribute("x", x + 0.5);
          sparks.setAttribute("y", y + 0.5);
          sparks.setAttribute("fill", STROKES[index]);
          contents[i].appendChild(sparks);
        }
      }
    }
  }
}

let gameAge = 0;

let start;
let frameId;

function draw(timeStamp) {
  if (start === undefined) {
    start = timeStamp;
  }
  const elapsed = timeStamp - start;
  const intendedAge = Math.min(FRAME_RATE * elapsed / 1000, gameAge + FRAME_RATE);

  const needsRedraw = (gameAge < intendedAge);

  while (gameAge < intendedAge) {
    game.tick();
    gameAge++;

    if (!game.games[0].active) {
      const {x1, y1, orientation} = MOVES[Math.floor(Math.random() * MOVES.length)];
      game.play(0, x1, y1, orientation);
    }

    if (!game.games[1].active) {
      const simpleGame = game.toSimpleGame(1);
      const {move, score} = maxDropletStrategy1(simpleGame);
      const {x1, y1, orientation} = MOVES[move];
      game.play(1, x1, y1, orientation);
    }
  }
  if (needsRedraw) {
    renderGame();
  }

  frameId = window.requestAnimationFrame(draw);
}

frameId = window.requestAnimationFrame(draw);

</script>
</head>
<body></body>
</html>
