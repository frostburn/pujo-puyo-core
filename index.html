<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    body {
      background-color: #223;
    }
  </style>
<script type="module">
import { MultiplayerGame, RED, GREEN, YELLOW, BLUE, PURPLE, WIDTH, LIFE_HEIGHT, GHOST_Y, MOVES, GARBAGE, combinedGarbageDisplay, maxDropletStrategy1 } from "./build/index.js";
import { transformPath, svgElement, makeDefs } from "./build/svgdefs.js";

// TODO: User input
// TODO: Sound ques
// TODO: Responsive layout

const FRAME_RATE = 30;

// 'RGYBPN'
const STROKES = ["#d22", "#2d2", "#dd2", "#22e", "#d2c", "rgba(20, 160, 160, 0.88)"];
const FILLS = ["#922", "#292", "#882", "#229", "#828", "rgba(30, 255, 255, 0.94)"];
const IGNITION_FILL = "#eed";
const STROKE_WIDTH = 0.15;

const CHAIN_FILL = "rgba(255, 250, 240, 0.2)";
const CHAIN_BORDER = "rgba(50, 40, 30, 0.4)";
const CHAIN_BORDER_WIDTH = 0.1;

const LEFT_SCREEN_X = 1;
const LEFT_SCREEN_Y = 2;
const RIGHT_SCREEN_X = 10;
const RIGHT_SCREEN_Y = LEFT_SCREEN_Y;

const game = new MultiplayerGame();

const NEXT_CHAIN_CARDS = [0, 2];
const IGNITION_CENTERS = [[0, 0], [0, 0]];

document.body.appendChild(makeDefs());

const container = document.createElement("div");
document.body.appendChild(container);

function juggleCards(cardIndex) {
  return [1, 0, 3, 2][cardIndex];
}

const svg = svgElement("svg");
svg.setAttribute("width", "95vh");
svg.setAttribute("height", "95vh");
svg.setAttribute("viewBox", "0 0 19 19");
container.appendChild(svg);

// Styles
const style = svgElement("style");
style.textContent = (
  ".score-label {font: bold 0.7px sans-serif; fill:azure;} " +
  ".score {font: bold 0.7px monospace; fill:azure;} " +
  ".all-clear {font: bold 1px sans-serif; fill:aliceblue; stroke:cornflowerblue; stroke-width:0.035px; stroke-linejoin:round; stroke-linecap:round;} "+
  ".chain {font: bold 0.8px sans-serif; fill:#fee; stroke:rgba(85, 83, 80, 0.7); stroke-width:0.04px;} "
);
svg.appendChild(style);

// Visible elements
const leftScreen = svgElement("use");
leftScreen.setAttribute("href", "#screen");
leftScreen.setAttribute("x", LEFT_SCREEN_X);
leftScreen.setAttribute("y", LEFT_SCREEN_Y);
svg.appendChild(leftScreen);

const rightScreen = svgElement("use");
rightScreen.setAttribute("href", "#screen");
rightScreen.setAttribute("x", RIGHT_SCREEN_X);
rightScreen.setAttribute("y", RIGHT_SCREEN_Y);
svg.appendChild(rightScreen);

const allClearLabels = [];
for (let i = 0; i < 2; ++i) {
  const allClearPath = svgElement("path");
  allClearPath.setAttribute("id", `all-clear-path-${i}`);
  if (i === 0) {
    allClearPath.setAttribute("d", `M ${LEFT_SCREEN_X+0.9} ${LEFT_SCREEN_Y+2} q 2 -0.5 4 0`);
  } else {
    allClearPath.setAttribute("d", `M ${RIGHT_SCREEN_X+0.9} ${RIGHT_SCREEN_Y+2} q 2 -0.5 4 0`);
  }
  allClearPath.setAttribute("fill", "none");
  svg.appendChild(allClearPath);
  const text = svgElement("text");
  const textPath = svgElement("textPath");
  textPath.setAttribute("href", `#all-clear-path-${i}`);
  text.appendChild(textPath);
  text.classList.add("all-clear");
  svg.appendChild(text);

  allClearLabels.push(textPath);
}

const leftContent = svgElement("g");
leftContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftContent);

const rightContent = svgElement("g");
rightContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightContent);

const contents = [leftContent, rightContent];

const chainBoxes = [];
const chainTexts = [];
const chainAnimations = [];
const chains = [];
for (let i = 0; i < 4; ++i) {
  const chain = svgElement("g");
  const chainBox = svgElement("rect");
  chainBox.setAttribute("rx", 0.2);
  chainBox.setAttribute("ry", 0.2);
  chainBox.setAttribute("height", 1);
  chainBox.setAttribute("fill", CHAIN_FILL);
  chainBox.setAttribute("stroke", CHAIN_BORDER);
  chainBox.setAttribute("stroke-width", CHAIN_BORDER_WIDTH);
  const chainText = svgElement("text");
  chainText.classList.add("chain");
  chainText.textContent = "0-Chain";
  chainText.setAttribute("x", 0.2);
  chainText.setAttribute("y", 0.75);
  chain.appendChild(chainBox);
  chain.appendChild(chainText);

  const animation = svgElement("animate");
  animation.setAttribute("attributeName", "opacity");
  animation.setAttribute("values", "0");
  animation.setAttribute("begin", "0s");
  animation.setAttribute("dur", "1.3s");
  animation.setAttribute("repeatCount", "1");
  animation.setAttribute("fill", "freeze");
  chain.appendChild(animation);

  chainBoxes.push(chainBox);
  chainTexts.push(chainText);
  chainAnimations.push(animation);
  chains.push(chain);

  svg.appendChild(chain);
}

function panelAt(x, y, color, connectivity = 0, jiggle = false, ignited = false) {
  const element = svgElement("use");
  if (color === GARBAGE) {
    element.setAttribute("href", jiggle ? "#jiggling-garbage": "#garbage");
  } else {
    element.setAttribute("href", `#panel${connectivity}`);
  }
  element.setAttribute("x", x + 0.5);
  element.setAttribute("y", y + 0.5);
  element.setAttribute("fill", ignited ? IGNITION_FILL : FILLS[color]);
  element.setAttribute("stroke", STROKES[color]);
  element.setAttribute("stroke-width", STROKE_WIDTH);
  if (color === GARBAGE) {
    return element;
  }
  const group = svgElement("g");
  group.appendChild(element);
  const glyph = svgElement("use");
  glyph.setAttribute("x", x + 0.5);
  glyph.setAttribute("y", y + 0.5);
  glyph.setAttribute("fill", STROKES[color]);
  if (color === RED) {
    glyph.setAttribute("href", jiggle ? "#jiggling-heart" : "#heart");
  } else if (color === GREEN) {
    glyph.setAttribute("href", jiggle ? "#jiggling-circle" : "#small-circle");
  } else if (color === YELLOW) {
    glyph.setAttribute("href", jiggle ? "#jiggling-star" : "#small-star");
  } else if (color === BLUE) {
    glyph.setAttribute("href", jiggle ? "#jiggling-moon" : "#small-moon");
  } else if (color === PURPLE) {
    glyph.setAttribute("href", jiggle ? "#jiggling-diamond" : "#small-diamond");
  }
  group.appendChild(glyph);
  return group;
}

function renderGame() {
  const gameState = game.state;

  for (let i = 0; i < 2; ++i) {
    const currentTime = svg.getCurrentTime();
    const newChildren = [];

    const chainNumber = gameState[i].screen.chainNumber;
    if (chainNumber > 0) {
      const cardIndex = juggleCards(NEXT_CHAIN_CARDS[i]);
      chainTexts[cardIndex].textContent = `${chainNumber}-Chain`;
      chainBoxes[cardIndex].setAttribute("width", chainTexts[i].getBBox().width + 0.4);
    }

    allClearLabels[i].textContent = gameState[i].allClearBonus ? "All Clear" : "";

    const garbageDisplay = combinedGarbageDisplay(gameState[i].pendingGarbage, gameState[i].lateGarbage);
    garbageDisplay.forEach((symbol, x) => {
      if (symbol === "rock") {
        symbol = "spade";
      } else if (symbol === "crown") {
        symbol = "diamond";
      }
      const glyph = svgElement("use");
      glyph.setAttribute("href", "#" + symbol);
      glyph.setAttribute("fill", FILLS[GARBAGE]);
      glyph.setAttribute("stroke", STROKES[GARBAGE]);
      glyph.setAttribute("stroke-width", STROKE_WIDTH);
      glyph.setAttribute("x", x + 0.5);
      glyph.setAttribute("y", -0.9);
      newChildren.push(glyph);
    });

    const previewBag = gameState[i].visibleBag.slice(-4);
    newChildren.push(panelAt(WIDTH + 0.5, 1, previewBag[0]));
    newChildren.push(panelAt(WIDTH + 0.5, 0, previewBag[1]));
    newChildren.push(panelAt(WIDTH + 1, 3.2, previewBag[2]));
    newChildren.push(panelAt(WIDTH + 1, 2.2, previewBag[3]));

    let numIgnitions = 0;
    let ignitionX = 0;
    let ignitionY = 0;

    for (let y = 0; y < LIFE_HEIGHT; ++y) {
      for (let x = 0; x < WIDTH; ++x) {
        const arrayIndex = x + (y + GHOST_Y + 1) * WIDTH;
        const index = gameState[i].screen.grid[arrayIndex];
        if (index >= 0) {
          const screen = gameState[i].screen;
          if (screen.ignited[arrayIndex]) {
            numIgnitions++;
            ignitionX += x;
            ignitionY += y;
          }

          if (screen.sparking[arrayIndex]) {
            // Garbage sparks are invisible even if they still support the panels above.
            if (index !== GARBAGE) {
              const sparks = svgElement("use");
              sparks.setAttribute("href", "#sparks");
              sparks.setAttribute("x", x + 0.5);
              sparks.setAttribute("y", y + 0.5);
              sparks.setAttribute("fill", STROKES[index]);
              newChildren.push(sparks);
            }
          } else {
            const panel = panelAt(x, y, index, screen.connectivity[arrayIndex], screen.jiggling[arrayIndex], screen.ignited[arrayIndex]);
            if (screen.falling[arrayIndex]) {
              const animation = svgElement("animateTransform");
              animation.setAttribute("attributeName", "transform");
              animation.setAttribute("attributeType", "XML");
              animation.setAttribute("type", "translate");
              animation.setAttribute("from", "0 0");
              animation.setAttribute("to", "0 1");
              animation.setAttribute("begin", `${currentTime}s`);
              animation.setAttribute("dur", `${1/FRAME_RATE}s`);
              animation.setAttribute("repeatCount", 1);
              animation.setAttribute("fill", "freeze");

              panel.appendChild(animation);
            }

            newChildren.push(panel);
          }
        }
      }
    }

    if (numIgnitions) {
      IGNITION_CENTERS[i][0] = ignitionX / numIgnitions;
      IGNITION_CENTERS[i][1] = ignitionY / numIgnitions;
    }

    contents[i].replaceChildren(...newChildren);

    const scoreLabel = svgElement("text");
    scoreLabel.setAttribute("y", LIFE_HEIGHT+0.8);
    scoreLabel.classList.add("score-label");
    scoreLabel.textContent = "Score:";
    contents[i].appendChild(scoreLabel);

    const score = svgElement("text");
    score.classList.add("score");
    score.setAttribute("y", LIFE_HEIGHT+0.8);
    score.setAttribute("dx", scoreLabel.getBBox().width + 0.1);
    score.textContent = gameState[i].score;
    contents[i].appendChild(score);

  }
}

let gameAge = 0;

let start;
let frameId;

function draw(timeStamp) {
  if (start === undefined) {
    start = timeStamp;
  }
  const elapsed = timeStamp - start;
  const intendedAge = Math.min(FRAME_RATE * elapsed / 1000, gameAge + FRAME_RATE);

  const needsRedraw = (gameAge < intendedAge);

  while (gameAge < intendedAge) {
    const tickResults = game.tick();
    gameAge++;

    for (let i = 0; i < 2; ++i) {
      if (tickResults[i].didClear) {
        const x = i === 0 ? LEFT_SCREEN_X : RIGHT_SCREEN_X;
        const y = i === 0 ? LEFT_SCREEN_Y : RIGHT_SCREEN_Y;
        chains[NEXT_CHAIN_CARDS[i]].setAttribute("transform", `translate(${x + IGNITION_CENTERS[i][0]}, ${y + IGNITION_CENTERS[i][1] - 0.5})`);

        chainAnimations[NEXT_CHAIN_CARDS[i]].setAttribute("begin", `${svg.getCurrentTime()}s`);
        chainAnimations[NEXT_CHAIN_CARDS[i]].setAttribute("values", "0;1;0.95;0.9;0.8;0.7;0");
        NEXT_CHAIN_CARDS[i] = juggleCards(NEXT_CHAIN_CARDS[i]);
      }
    }

    // TODO: Worker thread for maxDroplet2.
    if (!game.games[0].busy) {
      const {x1, y1, orientation} = MOVES[Math.floor(Math.random() * MOVES.length)];
      if (game.toSimpleGame(0).availableMoves.length) {
        game.play(0, x1, y1, orientation);
      }
    }

    if (!game.games[1].busy) {
      const simpleGame = game.toSimpleGame(1);
      const {move, score} = maxDropletStrategy1(simpleGame);
      const {x1, y1, orientation} = MOVES[move];
      if (game.toSimpleGame(1).availableMoves.length) {
        game.play(1, x1, y1, orientation);
      }
    }
  }
  if (needsRedraw) {
    renderGame();
  }

  frameId = window.requestAnimationFrame(draw);
}

frameId = window.requestAnimationFrame(draw);

const panicButton = document.createElement("button");
panicButton.onclick = () => window.cancelAnimationFrame(frameId);
panicButton.textContent = "stop";
document.body.appendChild(panicButton);

</script>
</head>
<body></body>
</html>
