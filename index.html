<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    body {
      background-color: #223;
    }
  </style>
<script type="module">
import { MultiplayerGame, WIDTH, LIFE_HEIGHT, GHOST_Y, MOVES, maxDropletStrategy1 } from "./build/index.js";

const FRAME_RATE = 15;

// 'RGYBPN'
const FILLS = ["red", "lime", "yellow", "blue", "fuchsia", "cyan"];

const LEFT_SCREEN_X = 1;
const LEFT_SCREEN_Y = 1;
const RIGHT_SCREEN_X = 10;
const RIGHT_SCREEN_Y = LEFT_SCREEN_Y;

const SVG_NS = "http://www.w3.org/2000/svg";

const game = new MultiplayerGame();

// TODO: Piece preview
// TODO: Incoming garbage

const container = document.createElement("div");

function svgElement(qualifiedName) {
  return document.createElementNS(SVG_NS, qualifiedName);
}

const svg = svgElement("svg");
svg.setAttribute("width", "95vh");
svg.setAttribute("height", "95vh");
svg.setAttribute("viewBox", "0 0 19 19");

// Defs
const defs = svgElement("defs");

const puyoDef = svgElement("circle");
puyoDef.setAttribute("id", "puyo");
puyoDef.setAttribute("r", 0.44);
puyoDef.setAttribute("stroke", "gainsboro");
puyoDef.setAttribute("stroke-width", "0.07");
defs.appendChild(puyoDef);

const sparksDef = svgElement("g");
sparksDef.setAttribute("id", "sparks");
for (let j = 0; j < 5; ++j) {
  const theta = 2 * Math.PI * j / 5;
  const spark = svgElement("circle");
  spark.setAttribute("cx", Math.cos(theta) * 0.3);
  spark.setAttribute("cy", Math.sin(theta) * 0.3);
  spark.setAttribute("r", 0.1);
  sparksDef.appendChild(spark);
}
const animation = svgElement("animateTransform");
animation.setAttribute("attributeName", "transform");
animation.setAttribute("type", "rotate");
animation.setAttribute("from", `0`);
animation.setAttribute("to", `360`);
animation.setAttribute("dur", "2s");
animation.setAttribute("repeatCount", "indefinite");
sparksDef.appendChild(animation);
defs.appendChild(sparksDef);

svg.appendChild(defs);

// Visible elements
const leftScreen = svgElement("rect");

leftScreen.setAttribute("x", LEFT_SCREEN_X);
leftScreen.setAttribute("y", LEFT_SCREEN_Y);

const rightScreen = svgElement("rect");

rightScreen.setAttribute("x", RIGHT_SCREEN_X);
rightScreen.setAttribute("y", RIGHT_SCREEN_Y);

const screens = [leftScreen, rightScreen];

screens.forEach(screen => {
  screen.setAttribute("width", WIDTH);
  screen.setAttribute("height", LIFE_HEIGHT);
  screen.setAttribute("fill", "none");
  screen.setAttribute("stroke", "black");
  screen.setAttribute("stroke-width", "0.05");
  screen.setAttribute("rx", "0.1");
  screen.setAttribute("ry", "0.1");
  svg.appendChild(screen);
})

const leftContent = svgElement("g");
leftContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftContent);

const rightContent = svgElement("g");
rightContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightContent);

const contents = [leftContent, rightContent];

container.appendChild(svg);
document.body.appendChild(container);

function renderGame() {
  leftContent.replaceChildren();
  rightContent.replaceChildren();

  const gameState = game.state;

  for (let i = 0; i < 2; ++i) {
    for (let y = 0; y < LIFE_HEIGHT; ++y) {
      for (let x = 0; x < WIDTH; ++x) {
        const arrayIndex = x + (y + GHOST_Y + 1) * WIDTH;
        let index = gameState[i].screen.supported[arrayIndex];
        let falling = false;
        if (index < 0) {
          index = gameState[i].screen.unsupported[arrayIndex];
          falling = true;
        }
        if (index >= 0) {
          const puyo = svgElement("use");
          puyo.setAttribute("href", "#puyo");
          puyo.setAttribute("x", x + 0.5);
          puyo.setAttribute("y", y + 0.5);
          puyo.setAttribute("fill", FILLS[index]);

          if (falling) {
            const animation = svgElement("animate");
            animation.setAttribute("attributeName", "y");
            animation.setAttribute("to", y + 1.5);
            animation.setAttribute("begin", `${svg.getCurrentTime()}s`);
            animation.setAttribute("dur", `${1/FRAME_RATE}s`);
            animation.setAttribute("repeatCount", 1);
            animation.setAttribute("fill", "freeze");

            puyo.appendChild(animation);
          }

          contents[i].appendChild(puyo);
        }

        index = gameState[i].screen.sparks[arrayIndex];
        if (index >= 0) {
          const sparks = svgElement("use");
          sparks.setAttribute("href", "#sparks");
          sparks.setAttribute("x", x + 0.5);
          sparks.setAttribute("y", y + 0.5);
          sparks.setAttribute("fill", FILLS[index]);
          contents[i].appendChild(sparks);
        }
      }
    }
  }
}

let gameAge = 0;

let start;
let frameId;

function draw(timeStamp) {
  if (start === undefined) {
    start = timeStamp;
  }
  const elapsed = timeStamp - start;
  const intendedAge = Math.min(FRAME_RATE * elapsed / 1000, gameAge + FRAME_RATE);

  const needsRedraw = (gameAge < intendedAge);

  while (gameAge < intendedAge) {
    game.tick();
    gameAge++;

    if (!game.games[0].active) {
      const {x1, y1, orientation} = MOVES[Math.floor(Math.random() * MOVES.length)];
      game.play(0, x1, y1, orientation);
    }

    if (!game.games[1].active) {
      const simpleGame = game.toSimpleGame(1);
      const {move, score} = maxDropletStrategy1(simpleGame);
      const {x1, y1, orientation} = MOVES[move];
      game.play(1, x1, y1, orientation);
    }
  }
  if (needsRedraw) {
    renderGame();
  }

  frameId = window.requestAnimationFrame(draw);
}

frameId = window.requestAnimationFrame(draw);

</script>
</head>
<body></body>
</html>
