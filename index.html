<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    body {
      background-color: #223;
    }
  </style>
<script type="module">
import { MultiplayerGame, RED, GREEN, YELLOW, BLUE, PURPLE, WIDTH, LIFE_HEIGHT, GHOST_Y, MOVES, GARBAGE, combinedGarbageDisplay, maxDropletStrategy1 } from "./build/index.js";
import { transformPath, svgElement, makeDefs } from "./build/svgdefs.js";
import { createSoftSquare, arpegiate, PingPongDelay, edArpeggio } from "./build/sound.js";

// TODO: User input
// TODO: Responsive layout

const strategyWorker = new Worker("./build/worker.js");
let waitingForStrategy = false;

const FRAME_RATE = 30;

// 'RGYBPN'
const STROKES = ["#d22", "#2d2", "#dd2", "#22e", "#d2c", "rgba(20, 160, 160, 0.88)"];
const FILLS = ["#922", "#292", "#882", "#229", "#828", "rgba(30, 255, 255, 0.94)"];
const IGNITION_FILL = "#eed";
const STROKE_WIDTH = 0.15;

const CHAIN_FILL = "rgba(255, 250, 240, 0.2)";
const CHAIN_BORDER = "rgba(50, 40, 30, 0.4)";
const CHAIN_BORDER_WIDTH = 0.1;

const LEFT_SCREEN_X = 1;
const LEFT_SCREEN_Y = 2;
const RIGHT_SCREEN_X = 10;
const RIGHT_SCREEN_Y = LEFT_SCREEN_Y;

const game = new MultiplayerGame();

const NEXT_CHAIN_CARDS = [0, 2];
const IGNITION_CENTERS = [[0, 0], [0, 0]];

document.body.appendChild(makeDefs());

const container = document.createElement("div");
document.body.appendChild(container);

// Web Audio API requires user interaction.
// TODO: Prettier buttons/other initialization system.
const startButton = document.createElement("button");
startButton.textContent = "start";
startButton.style = "float: left";
container.appendChild(startButton);

function juggleCards(cardIndex) {
  return [1, 0, 3, 2][cardIndex];
}

const svg = svgElement("svg");
svg.setAttribute("width", "95vh");
svg.setAttribute("height", "95vh");
svg.setAttribute("viewBox", "0 0 19 19");
container.appendChild(svg);

// Styles
const style = svgElement("style");
style.textContent = (
  ".score-label {font: bold 0.7px sans-serif; fill:azure;} " +
  ".score {font: bold 0.7px monospace; fill:azure;} " +
  ".all-clear {font: bold 1px sans-serif; fill:aliceblue; stroke:cornflowerblue; stroke-width:0.035px; stroke-linejoin:round; stroke-linecap:round;} "+
  ".chain {font: bold 0.8px sans-serif; fill:#fee; stroke:rgba(85, 83, 80, 0.7); stroke-width:0.04px;} "
);
svg.appendChild(style);

// Visible elements
const leftScreen = svgElement("use");
leftScreen.setAttribute("href", "#screen");
leftScreen.setAttribute("x", LEFT_SCREEN_X);
leftScreen.setAttribute("y", LEFT_SCREEN_Y);
svg.appendChild(leftScreen);

const rightScreen = svgElement("use");
rightScreen.setAttribute("href", "#screen");
rightScreen.setAttribute("x", RIGHT_SCREEN_X);
rightScreen.setAttribute("y", RIGHT_SCREEN_Y);
svg.appendChild(rightScreen);

const allClearLabels = [];
for (let i = 0; i < 2; ++i) {
  const allClearPath = svgElement("path");
  allClearPath.setAttribute("id", `all-clear-path-${i}`);
  if (i === 0) {
    allClearPath.setAttribute("d", `M ${LEFT_SCREEN_X+0.9} ${LEFT_SCREEN_Y+2} q 2 -0.5 4 0`);
  } else {
    allClearPath.setAttribute("d", `M ${RIGHT_SCREEN_X+0.9} ${RIGHT_SCREEN_Y+2} q 2 -0.5 4 0`);
  }
  allClearPath.setAttribute("fill", "none");
  svg.appendChild(allClearPath);
  const text = svgElement("text");
  const textPath = svgElement("textPath");
  textPath.setAttribute("href", `#all-clear-path-${i}`);
  text.appendChild(textPath);
  text.classList.add("all-clear");
  svg.appendChild(text);

  allClearLabels.push(textPath);
}

const leftContent = svgElement("g");
leftContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftContent);

const rightContent = svgElement("g");
rightContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightContent);

const contents = [leftContent, rightContent];

const chainBoxes = [];
const chainTexts = [];
const chainAnimations = [];
const chains = [];
for (let i = 0; i < 4; ++i) {
  const chain = svgElement("g");
  const chainBox = svgElement("rect");
  chainBox.setAttribute("rx", 0.2);
  chainBox.setAttribute("ry", 0.2);
  chainBox.setAttribute("height", 1);
  chainBox.setAttribute("fill", CHAIN_FILL);
  chainBox.setAttribute("stroke", CHAIN_BORDER);
  chainBox.setAttribute("stroke-width", CHAIN_BORDER_WIDTH);
  const chainText = svgElement("text");
  chainText.classList.add("chain");
  chainText.textContent = "0-Chain";
  chainText.setAttribute("x", 0.2);
  chainText.setAttribute("y", 0.75);
  chain.appendChild(chainBox);
  chain.appendChild(chainText);

  const animation = svgElement("animate");
  animation.setAttribute("attributeName", "opacity");
  animation.setAttribute("values", "0");
  animation.setAttribute("begin", "0s");
  animation.setAttribute("dur", "1.3s");
  animation.setAttribute("repeatCount", "1");
  animation.setAttribute("fill", "freeze");
  chain.appendChild(animation);

  chainBoxes.push(chainBox);
  chainTexts.push(chainText);
  chainAnimations.push(animation);
  chains.push(chain);

  svg.appendChild(chain);
}

function panelAt(x, y, color, connectivity = 0, jiggle = false, ignited = false) {
  const element = svgElement("use");
  if (color === GARBAGE) {
    element.setAttribute("href", jiggle ? "#jiggling-garbage": "#garbage");
  } else {
    element.setAttribute("href", `#panel${connectivity}`);
  }
  element.setAttribute("x", x + 0.5);
  element.setAttribute("y", y + 0.5);
  element.setAttribute("fill", ignited ? IGNITION_FILL : FILLS[color]);
  element.setAttribute("stroke", STROKES[color]);
  element.setAttribute("stroke-width", STROKE_WIDTH);
  if (color === GARBAGE) {
    return element;
  }
  const group = svgElement("g");
  group.appendChild(element);
  const glyph = svgElement("use");
  glyph.setAttribute("x", x + 0.5);
  glyph.setAttribute("y", y + 0.5);
  glyph.setAttribute("fill", STROKES[color]);
  if (color === RED) {
    glyph.setAttribute("href", jiggle ? "#jiggling-heart" : "#heart");
  } else if (color === GREEN) {
    glyph.setAttribute("href", jiggle ? "#jiggling-circle" : "#small-circle");
  } else if (color === YELLOW) {
    glyph.setAttribute("href", jiggle ? "#jiggling-star" : "#small-star");
  } else if (color === BLUE) {
    glyph.setAttribute("href", jiggle ? "#jiggling-moon" : "#small-moon");
  } else if (color === PURPLE) {
    glyph.setAttribute("href", jiggle ? "#jiggling-diamond" : "#small-diamond");
  }
  group.appendChild(glyph);
  return group;
}

function renderGame() {
  const gameState = game.state;

  for (let i = 0; i < 2; ++i) {
    const currentTime = svg.getCurrentTime();
    const newChildren = [];

    const chainNumber = gameState[i].screen.chainNumber;
    if (chainNumber > 0) {
      const cardIndex = juggleCards(NEXT_CHAIN_CARDS[i]);
      chainTexts[cardIndex].textContent = `${chainNumber}-Chain`;
      chainBoxes[cardIndex].setAttribute("width", chainTexts[i].getBBox().width + 0.4);
    }

    allClearLabels[i].textContent = gameState[i].allClearBonus ? "All Clear" : "";

    const garbageDisplay = combinedGarbageDisplay(gameState[i].pendingGarbage, gameState[i].lateGarbage);
    garbageDisplay.forEach((symbol, x) => {
      if (symbol === "rock") {
        symbol = "spade";
      } else if (symbol === "crown") {
        symbol = "diamond";
      }
      const glyph = svgElement("use");
      glyph.setAttribute("href", "#" + symbol);
      glyph.setAttribute("fill", FILLS[GARBAGE]);
      glyph.setAttribute("stroke", STROKES[GARBAGE]);
      glyph.setAttribute("stroke-width", STROKE_WIDTH);
      glyph.setAttribute("x", x + 0.5);
      glyph.setAttribute("y", -0.9);
      newChildren.push(glyph);
    });

    const previewBag = gameState[i].visibleBag.slice(-4);
    newChildren.push(panelAt(WIDTH + 0.5, 1, previewBag[0]));
    newChildren.push(panelAt(WIDTH + 0.5, 0, previewBag[1]));
    newChildren.push(panelAt(WIDTH + 1, 3.2, previewBag[2]));
    newChildren.push(panelAt(WIDTH + 1, 2.2, previewBag[3]));

    let numIgnitions = 0;
    let ignitionX = 0;
    let ignitionY = 0;

    for (let y = 0; y < LIFE_HEIGHT; ++y) {
      for (let x = 0; x < WIDTH; ++x) {
        const arrayIndex = x + (y + GHOST_Y + 1) * WIDTH;
        const index = gameState[i].screen.grid[arrayIndex];
        if (index >= 0) {
          const screen = gameState[i].screen;
          if (screen.ignited[arrayIndex]) {
            numIgnitions++;
            ignitionX += x;
            ignitionY += y;
          }

          if (screen.sparking[arrayIndex]) {
            // Garbage sparks are invisible even if they still support the panels above.
            if (index !== GARBAGE) {
              const sparks = svgElement("use");
              sparks.setAttribute("href", "#sparks");
              sparks.setAttribute("x", x + 0.5);
              sparks.setAttribute("y", y + 0.5);
              sparks.setAttribute("fill", STROKES[index]);
              newChildren.push(sparks);
            }
          } else {
            const panel = panelAt(x, y, index, screen.connectivity[arrayIndex], screen.jiggling[arrayIndex], screen.ignited[arrayIndex]);
            if (screen.falling[arrayIndex]) {
              const animation = svgElement("animateTransform");
              animation.setAttribute("attributeName", "transform");
              animation.setAttribute("attributeType", "XML");
              animation.setAttribute("type", "translate");
              animation.setAttribute("from", "0 0");
              animation.setAttribute("to", "0 1");
              animation.setAttribute("begin", `${currentTime}s`);
              animation.setAttribute("dur", `${1/FRAME_RATE}s`);
              animation.setAttribute("repeatCount", 1);
              animation.setAttribute("fill", "freeze");

              panel.appendChild(animation);
            }

            newChildren.push(panel);
          }
        }
      }
    }

    if (numIgnitions) {
      IGNITION_CENTERS[i][0] = ignitionX / numIgnitions;
      IGNITION_CENTERS[i][1] = ignitionY / numIgnitions;
    }

    contents[i].replaceChildren(...newChildren);

    const scoreLabel = svgElement("text");
    scoreLabel.setAttribute("y", LIFE_HEIGHT+0.8);
    scoreLabel.classList.add("score-label");
    scoreLabel.textContent = "Score:";
    contents[i].appendChild(scoreLabel);

    const score = svgElement("text");
    score.classList.add("score");
    score.setAttribute("y", LIFE_HEIGHT+0.8);
    score.setAttribute("dx", scoreLabel.getBBox().width + 0.1);
    score.textContent = gameState[i].score;
    contents[i].appendChild(score);

  }
}

let gameAge = 0;

let start;
let frameId;

function draw(timeStamp) {
  if (start === undefined) {
    start = timeStamp;
  }
  const elapsed = timeStamp - start;
  const intendedAge = Math.min(FRAME_RATE * elapsed / 1000, gameAge + FRAME_RATE);

  const needsRedraw = (gameAge < intendedAge);

  while (gameAge < intendedAge) {
    const tickResults = game.tick();
    gameAge++;

    for (let i = 0; i < 2; ++i) {
      if (tickResults[i].didClear) {
        const x = i === 0 ? LEFT_SCREEN_X : RIGHT_SCREEN_X;
        const y = i === 0 ? LEFT_SCREEN_Y : RIGHT_SCREEN_Y;
        chains[NEXT_CHAIN_CARDS[i]].setAttribute("transform", `translate(${x + IGNITION_CENTERS[i][0]}, ${y + IGNITION_CENTERS[i][1] - 0.5})`);

        chainAnimations[NEXT_CHAIN_CARDS[i]].setAttribute("begin", `${svg.getCurrentTime()}s`);
        chainAnimations[NEXT_CHAIN_CARDS[i]].setAttribute("values", "0;1;0.95;0.9;0.8;0.7;0");
        NEXT_CHAIN_CARDS[i] = juggleCards(NEXT_CHAIN_CARDS[i]);

        // TODO: This can go on the card directly, right?
        playSoundFX(i, tickResults[i].chainNumber);
      }
    }

    // Worker thread for maxDroplet2.
    if (!game.games[0].busy && !waitingForStrategy) {
      waitingForStrategy = true;
      strategyWorker.postMessage(game.toSimpleGame(0));
    }

    if (!game.games[1].busy) {
      const simpleGame = game.toSimpleGame(1);
      const {move, score} = maxDropletStrategy1(simpleGame);
      const {x1, y1, orientation} = MOVES[move];
      if (game.toSimpleGame(1).availableMoves.length) {
        game.play(1, x1, y1, orientation);
      }
    }
  }
  if (needsRedraw) {
    renderGame();
  }

  frameId = window.requestAnimationFrame(draw);
}

// Pre-render once.
renderGame();

// Worker thread for maxDroplet2.
strategyWorker.onmessage = (e) => {
  const {move, score} = e.data;
  const {x1, y1, orientation} = MOVES[move];
  if (game.toSimpleGame(0).availableMoves.length) {
    game.play(0, x1, y1, orientation);
  }
  waitingForStrategy = false;
};

// Sound FX
const AUDIO_LAG = 0.01;  // Make audio laggy but less clicky.
const MIRACLE_HEXAD_RATIOS = [1.12373, 1.24848, 1.42557, 1.60195, 1.75156];
const MIRACLE_CHORD = [830];
for (let i = 0; i < 5; ++i) {
  MIRACLE_CHORD.push(MIRACLE_HEXAD_RATIOS[i] * 830);
}
for (let i = 3; i >= 0; --i) {
  MIRACLE_CHORD.push(MIRACLE_HEXAD_RATIOS[i] * 1660);
}

const ARPEGGIOS = [
  edArpeggio([0, 1, 2, 3], 7, 2, 430),  // 7-edo cluster, slightly lower.
  edArpeggio([0, 2, 4, 6]),  // Whole-tone cluster.
  edArpeggio([0, 1, 2, 3], 5, 2, 453),  // 5-edo cluster, slightly higher.
  edArpeggio([1, 4, 7, 10]),  // Fully diminished chord.
  [494, 494 * 6/5, 494 * 3/2, 494 * 9 / 5],  // Just minor seventh chord.
  [523, 523 * 5/4, 523 * 6/4, 523 * 7/4],  // Harmonic seventh chord.
  edArpeggio([4, 8, 12, 16]),  // Augmented chord.
  [587, 587 * 4/3, 587 * 16/9, 587 * 64/27],  // Stack of just fourths.
  [622, 622 * 11/8, 622 * 121/60, 622 * 1331/512],  // Stack of just superfourths.
  [659, 659 * 3/2, 659 * 9/4, 659 * 27/8],  // Stack of just fifths.
  [6660 / 9, 6660 / 8, 6660 / 7, 6660 / 6, 6660 / 5, 6660 / 4, 6660 / 3],  // Subharmonics 9-3.
  edArpeggio([0, 1, 3, 5, 7, 11, 13], 9, 2, 698),  // Prime steps of 9-edo.
  [8624 / 11, 8624 / 10, 8624 / 9, 8624 / 8, 8624 / 7, 8624 / 6, 8624 / 5, 8624 / 4],  // Subharmonics 11-4.
  MIRACLE_CHORD,  // Essentially tempered Miracle hexad.
  [880, 880 * 13/10, 880 * 15/10, 880 * 16/10, 880 * 19/10, 880 * 18/10, 880 * 25/10, 880 * 24/10],  // Supermajor chord with otonal extensions.
  edArpeggio([0, 7, 13, 40, 36, 34, 20, 26, 30], 23, 2, 932),  // Anti-minor chord with random extensions.
  [2303, 1523, 3754, 2910, 3312, 2563, 3259, 1061, 2888],  // Completely random chord.
  [1209, 1336, 1477, 1633, 697, 770, 852, 941],  // DTMF.
  edArpeggio([0, 2, 3, 5, 2, 2, -2, 0, 0, -12, 12, 12]),  // The Lick.
];

let context;
const oscillators = [];
const envelopes = [];

startButton.onclick = () => {
  if (frameId === undefined) {
    frameId = window.requestAnimationFrame(draw);
  }

  if (context === undefined) {
    context = new AudioContext({latencyHint: "interactive"});

    const delay = new PingPongDelay(context, 1);
    delay.delayTime = 0.1;
    delay.feedback = 0.4;
    delay.separation = 0.3;
    delay.connect(context.destination);

    for (let i = 0; i < 2; ++i) {
      // Give each player a voice through slight variation of the oscillators.
      let oscillator;
      if (i === 0) {
        oscillator = createSoftSquare(context);
      } else {
        oscillator = createSoftSquare(context, 0.085, 0.42, 0.06);
      }
      const envelope = context.createGain();

      oscillator.connect(envelope).connect(delay.destination)

      envelope.gain.setValueAtTime(0, context.currentTime);
      oscillator.start(context.currentTime);
      oscillators.push(oscillator);
      envelopes.push(envelope);
    }
  }
}

function playSoundFX(player, chainNumber) {
  if (context === undefined) {
    return;
  }
  // Try to resolve some glitches
  oscillators[player].frequency.cancelScheduledValues(context.currentTime);
  oscillators[player].frequency.setValueAtTime(ARPEGGIOS[chainNumber][0], context.currentTime);
  envelopes[player].gain.cancelScheduledValues(context.currentTime);

  const now = context.currentTime + AUDIO_LAG;
  envelopes[player].gain.setValueAtTime(0.45, now);
  envelopes[player].gain.exponentialRampToValueAtTime(1e-5, now + 3);
  arpegiate(oscillators[player], ARPEGGIOS[chainNumber - 1], now, now + 3);
}

const panicButton = document.createElement("button");
panicButton.onclick = () => {
  window.cancelAnimationFrame(frameId);
  if (context !== undefined) {
    oscillators.forEach(oscillator => oscillator.stop());
    context.suspend();
  }
}
panicButton.textContent = "stop";
document.body.appendChild(panicButton);

</script>
</head>
<body></body>
</html>
