<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    body {
      background-color: #223;
    }
  </style>
<script type="module">
import { MultiplayerGame, RED, GREEN, YELLOW, BLUE, PURPLE, WIDTH, LIFE_HEIGHT, GHOST_Y, MOVES, GARBAGE, CONNECTS_DOWN, CONNECTS_UP, CONNECTS_RIGHT, CONNECTS_LEFT, combinedGarbageDisplay, maxDropletStrategy1 } from "./build/index.js";

// TODO: Chain cards
// TODO: Sound ques
// TODO: Pre-sparks
// TODO: Responsive layout

const FRAME_RATE = 30;

// 'RGYBPN'
const STROKES = ["#d22", "#2d2", "#dd2", "#22e", "#d2c", "rgba(20, 160, 160, 0.88)"];
const FILLS = ["#922", "#292", "#882", "#229", "#828", "rgba(30, 255, 255, 0.94)"];
const STROKE_WIDTH = 0.15;
const SCREEN_STROKE = "#101";
const SCREEN_FILL = "rgba(0, 0, 0, 0.1)";
const SCREEN_STROKE_WIDTH = 0.16;
const SCREEN_INNER_STROKE = "#112";
const SCREEN_INNER_STROKE_WIDTH = 0.06;
const SCREEN_INNER_DASHARRAY = "0.14 0.1 0.2 0.1";

const LEFT_SCREEN_X = 1;
const LEFT_SCREEN_Y = 2;
const RIGHT_SCREEN_X = 10;
const RIGHT_SCREEN_Y = LEFT_SCREEN_Y;

const SVG_NS = "http://www.w3.org/2000/svg";

const game = new MultiplayerGame();

const container = document.createElement("div");

function svgElement(qualifiedName) {
  return document.createElementNS(SVG_NS, qualifiedName);
}

const ARC_SCALE_FLAGS = [true, true, false, false, false, true, true];
const ARC_TRANSLATION_FLAGS = [false, false, false, false, false, true, true];
/**
 * Transform <path> element's definition by first re-scaling it and then translating the points.
 * NOTE: Likely incomplete and pretty much untested.
 */
function transformPath(d, scale = 1, dx = 0, dy = 0) {
  const transformed = [];
  let scaleFlags = [];
  let translationFlags = [];
  let horizontal = true;
  d.split(/\s+/).forEach(token => {
    let num = parseFloat(token);
    if (isNaN(num)) {
      transformed.push(token);
      horizontal = true;
      if (token.toUpperCase() === "A") {
        scaleFlags = [...ARC_SCALE_FLAGS];
        translationFlags = [...ARC_TRANSLATION_FLAGS];
      } else if (token.toUpperCase() === "V") {
        horizontal = false;
      }
      if (token === token.toLowerCase()) {
        translationFlags = Array(7).fill(false);
      }
    } else {
      let scaleFlag = true;
      let translationFlag = true;
      if (scaleFlags.length) {
        scaleFlag = scaleFlags.shift();
      }
      if (translationFlags.length) {
        translationFlag = translationFlags.shift();
      }
      if (scaleFlag) {
        num *= scale;
      }
      if (translationFlag) {
        num += (horizontal ? dx : dy);
        horizontal = !horizontal;
      }
      transformed.push(num.toString());
    }
  });
  return transformed.join(" ");
}

const svg = svgElement("svg");
svg.setAttribute("width", "95vh");
svg.setAttribute("height", "95vh");
svg.setAttribute("viewBox", "0 0 19 19");

// Styles
const style = svgElement("style");
style.textContent = ".score-label {font: bold 0.7px sans-serif; fill:azure;} .score {font: bold 0.7px monospace; fill:azure;}";
svg.appendChild(style);

// Defs
const defs = svgElement("defs");
svg.appendChild(defs);

const screenOutlineDef = svgElement("g");
screenOutlineDef.setAttribute("id", "screen-outline");

const mainScreen = svgElement("rect");
mainScreen.setAttribute("x", -0.1);
mainScreen.setAttribute("y", -0.1);
mainScreen.setAttribute("width", WIDTH + 0.2);
mainScreen.setAttribute("height", LIFE_HEIGHT + 0.2);
mainScreen.setAttribute("rx", "0.1");
mainScreen.setAttribute("ry", "0.1");
screenOutlineDef.appendChild(mainScreen);

const pieceBox = svgElement("path");
pieceBox.setAttribute("d",
  "M -0.1 0 " +
  "A 0.1 0.1 0 0 1 0 -0.1 " +
  "H 1 " +
  "A 0.1 0.1 0 0 1 1.1 0 " +
  "V 2 " +
  "A 0.1 0.1 0 0 0 1.2 2.1 " +
  "H 1.5 " +
  "A 0.1 0.1 0 0 1 1.6 2.2 " +
  "V 4.2 " +
  "A 0.1 0.1 0 0 1 1.5 4.3 " +
  "H 0.5 " +
  "A 0.1 0.1 0 0 1 0.4 4.2 " +
  "V 2.2 " +
  "A 0.1 0.1 0 0 0 0.3 2.1 " +
  "H 0 " +
  "A 0.1 0.1 0 0 1 -0.1 2 " +
  "Z"
);
pieceBox.setAttribute("transform", `translate(${WIDTH+0.5}, 0)`);
screenOutlineDef.appendChild(pieceBox);

defs.appendChild(screenOutlineDef);

const screenDef = svgElement("g");
screenDef.setAttribute("id", "screen");

const darkScreen = svgElement("use");
darkScreen.setAttribute("href", "#screen-outline");
darkScreen.setAttribute("fill", SCREEN_FILL);
darkScreen.setAttribute("stroke", SCREEN_STROKE);
darkScreen.setAttribute("stroke-width", SCREEN_STROKE_WIDTH);
screenDef.appendChild(darkScreen);

const lightDashes = svgElement("use");
lightDashes.setAttribute("href", "#screen-outline");
lightDashes.setAttribute("fill", "none");
lightDashes.setAttribute("stroke", SCREEN_INNER_STROKE);
lightDashes.setAttribute("stroke-width", SCREEN_INNER_STROKE_WIDTH);
lightDashes.setAttribute("stroke-dasharray", SCREEN_INNER_DASHARRAY);
screenDef.appendChild(lightDashes);

defs.appendChild(screenDef);

const sparksDef = svgElement("g");
sparksDef.setAttribute("id", "sparks");
for (let i = 0; i < 5; ++i) {
  const theta = 2 * Math.PI * i / 5;
  const spark = svgElement("circle");
  spark.setAttribute("cx", Math.cos(theta) * 0.3);
  spark.setAttribute("cy", Math.sin(theta) * 0.3);
  spark.setAttribute("r", 0.1);
  sparksDef.appendChild(spark);
}
{
  const animation = svgElement("animateTransform");
  animation.setAttribute("attributeName", "transform");
  animation.setAttribute("type", "rotate");
  animation.setAttribute("from", `0`);
  animation.setAttribute("to", `360`);
  animation.setAttribute("dur", "3s");
  animation.setAttribute("repeatCount", "indefinite");
  sparksDef.appendChild(animation);
}
defs.appendChild(sparksDef);

// Garbage queue indicators
const spadeDef = svgElement("path");
spadeDef.setAttribute("id", "spade");
const spadeD = (
  "M 0.3 0 " +
  "Q 0 0.6 0.5 0.8 " +
  "H -0.5 " +
  "Q 0 0.6 -0.3 0 " +
  "C -0.1 1 -1.8 0 0 -1 " +
  "C 1.8 0 0.1 1 0.3 0 " +
  "Z"
);
spadeDef.setAttribute("d", transformPath(spadeD, 0.45));
spadeDef.setAttribute("stroke-linejoin", "round");
defs.appendChild(spadeDef);

const moonDef = svgElement("path");
moonDef.setAttribute("id", "moon");
const moonD = "M 0 1 A 1.1 1.1 0 1 0 0 -1 A 1.04 1.04 0 0 1 0 1 Z";
moonDef.setAttribute("d", transformPath(moonD, 0.35, -0.25));
defs.appendChild(moonDef);

const diamondDef = svgElement("path");
diamondDef.setAttribute("id", "diamond");
const diamondD = "M 0 1 Q 0.55 0.55 1 0 Q 0.55 -0.55 0 -1 Q -0.55 -0.55 -1 0 Q -0.55 0.55 0 1 Z";
diamondDef.setAttribute("d", transformPath(diamondD, 0.4));
defs.appendChild(diamondDef);

const smallDef = svgElement("circle");
smallDef.setAttribute("id", "small");
smallDef.setAttribute("r", 0.2);
defs.appendChild(smallDef);

const largeDef = svgElement("circle");
largeDef.setAttribute("id", "large");
largeDef.setAttribute("r", 0.39);
defs.appendChild(largeDef);

const cometDef = svgElement("path");
cometDef.setAttribute("id", "comet");
const cometD = "M 0 1 A 1 1 0 0 1 0 -1 L 2 -1 L 0.5 -0.5 L 2.5 -0.1 L 0.3 0.3 L 1 1 Z";
cometDef.setAttribute("d", transformPath(cometD, 0.3, -0.15));
cometDef.setAttribute("transform", "rotate(-45)");
defs.appendChild(cometDef);

const starDef = svgElement("path");
starDef.setAttribute("id", "star");
let starD = "M 0 0.3";
const spikeDelta = Math.PI / 5;
for (let i = 1; i < 6; ++i) {
  const theta = 2 * Math.PI * i / 5;
  const x1 = 0.7 * Math.sin(theta - spikeDelta);
  const y1 = 0.7 * Math.cos(theta - spikeDelta);
  const x = 0.3 * Math.sin(theta);
  const y = 0.3 * Math.cos(theta);
  starD += ` Q ${x1} ${y1} ${x} ${y}`;
}
starD += " Z";
starDef.setAttribute("d", starD);
defs.appendChild(starDef);

// Panels

const squareClip = svgElement("clipPath");
squareClip.setAttribute("id", "square");
const square = svgElement("rect");
square.setAttribute("x", -0.505);
square.setAttribute("y", -0.505);
square.setAttribute("width", 1.1);
square.setAttribute("height", 1.1);
squareClip.appendChild(square);
defs.appendChild(squareClip);

for (let i = 0; i < 16; ++i) {
  const connectedDef = svgElement("polygon");
  connectedDef.setAttribute("id", `panel${i}`);

  let points = [
    [0.4, 0.3],
    [0.3, 0.4]
  ];
  if (i & CONNECTS_DOWN) {
    points = points.concat([
      [0.3, 0.6],
      [0.4, 0.7],
      [-0.4, 0.7],
      [-0.3, 0.6],
    ]);
  }
  points = points.concat([
    [-0.3, 0.4],
    [-0.4, 0.3]
  ]);
  if (i & CONNECTS_LEFT) {
    points = points.concat([
      [-0.6, 0.3],
      [-0.7, 0.4],
      [-0.7, -0.4],
      [-0.6, -0.3]
    ]);
  }
  points = points.concat([
    [-0.4, -0.3],
    [-0.3, -0.4]
  ]);
  if (i & CONNECTS_UP) {
    points = points.concat([
      [-0.3, -0.6],
      [-0.4, -0.7],
      [0.4, -0.7],
      [0.3, -0.6],
    ]);
  }
  points = points.concat([
    [0.3, -0.4],
    [0.4, -0.3]
  ]);
  if (i & CONNECTS_RIGHT) {
    points = points.concat([
      [0.6, -0.3],
      [0.7, -0.4],
      [0.7, 0.4],
      [0.6, 0.3],
    ]);
  }

  connectedDef.setAttribute("points", points.map(pair => pair.join(",")).join(" "));

  connectedDef.setAttribute("clip-path", "url(#square)");

  defs.appendChild(connectedDef);
}

const garbageDef = svgElement("circle");
garbageDef.setAttribute("id", "garbage");
garbageDef.setAttribute("r", 0.42);
defs.appendChild(garbageDef);

const jigglingGarbageDef = svgElement("ellipse");
jigglingGarbageDef.setAttribute("id", "jiggling-garbage");
jigglingGarbageDef.setAttribute("rx", 0.41);
jigglingGarbageDef.setAttribute("ry", 0.43);
{
  const animation = svgElement("animate");
  animation.setAttribute("attributeName", "rx");
  animation.setAttribute("values", "0.41;0.43;0.41");
  animation.setAttribute("dur", "0.3s");
  animation.setAttribute("repeatCount", "indefinite");
  jigglingGarbageDef.appendChild(animation);
}
{
  const animation = svgElement("animate");
  animation.setAttribute("attributeName", "ry");
  animation.setAttribute("values", "0.43;0.41;0.43");
  animation.setAttribute("dur", "0.3s");
  animation.setAttribute("repeatCount", "indefinite");
  jigglingGarbageDef.appendChild(animation);
}
defs.appendChild(jigglingGarbageDef);

// Panel identifiers
const JIGGLE_DUR = "0.2s";
const jiggleAnimation = svgElement("animate");
jiggleAnimation.setAttribute("attributeName", "y");
jiggleAnimation.setAttribute("values", "-0.05;0.05;-0.05");
jiggleAnimation.setAttribute("dur", JIGGLE_DUR);
jiggleAnimation.setAttribute("repeatCount", "indefinite");

const heartDef = svgElement("path");
heartDef.setAttribute("id", "heart");
const heartD = "M 0 1 C 1.8 0 0 -1 0 0 C 0 -1 -1.8 0 0 1 Z";
heartDef.setAttribute("d", transformPath(heartD, 0.3, -0.01, -0.07));
defs.appendChild(heartDef);

const jigglingHeartDef = svgElement("use");
jigglingHeartDef.setAttribute("id", "jiggling-heart");
jigglingHeartDef.setAttribute("href", "#heart");
jigglingHeartDef.appendChild(jiggleAnimation);
defs.appendChild(jigglingHeartDef);

const smallStarDef = svgElement("path");
smallStarDef.setAttribute("id", "small-star");
smallStarDef.setAttribute("d", transformPath(starD, -0.6, 0, -0.015));
defs.appendChild(smallStarDef);

const jigglingStarDef = svgElement("use");
jigglingStarDef.setAttribute("id", "jiggling-star");
jigglingStarDef.setAttribute("href", "#small-star");
jigglingStarDef.appendChild(jiggleAnimation.cloneNode());
defs.appendChild(jigglingStarDef);

const smallCirleDef = svgElement("circle");
smallCirleDef.setAttribute("id", "small-circle");
smallCirleDef.setAttribute("r", 0.2);
defs.appendChild(smallCirleDef);

const jigglingCircleDef = svgElement("use");
jigglingCircleDef.setAttribute("id", "jiggling-circle");
jigglingCircleDef.setAttribute("href", "#small-circle");
jigglingCircleDef.appendChild(jiggleAnimation.cloneNode());
defs.appendChild(jigglingCircleDef);

const smallMoonDef = svgElement("path");
smallMoonDef.setAttribute("id", "small-moon");
smallMoonDef.setAttribute("d", transformPath(moonD, -0.21, 0.15));
defs.appendChild(smallMoonDef);

const jigglingMoonDef = svgElement("use");
jigglingMoonDef.setAttribute("id", "jiggling-moon");
jigglingMoonDef.setAttribute("href", "#small-moon");
jigglingMoonDef.appendChild(jiggleAnimation.cloneNode());
defs.appendChild(jigglingMoonDef);

const smallDiamondDef = svgElement("path");
smallDiamondDef.setAttribute("id", "small-diamond");
smallDiamondDef.setAttribute("d", transformPath(diamondD, -0.24));
defs.appendChild(smallDiamondDef);

const jigglingDiamondDef = svgElement("use");
jigglingDiamondDef.setAttribute("id", "jiggling-diamond");
jigglingDiamondDef.setAttribute("href", "#small-diamond");
jigglingDiamondDef.appendChild(jiggleAnimation.cloneNode());
defs.appendChild(jigglingDiamondDef);

// Visible elements
const leftScreen = svgElement("use");
leftScreen.setAttribute("href", "#screen");
leftScreen.setAttribute("x", LEFT_SCREEN_X);
leftScreen.setAttribute("y", LEFT_SCREEN_Y);
svg.appendChild(leftScreen);

const rightScreen = svgElement("use");
rightScreen.setAttribute("href", "#screen");
rightScreen.setAttribute("x", RIGHT_SCREEN_X);
rightScreen.setAttribute("y", RIGHT_SCREEN_Y);
svg.appendChild(rightScreen);

const leftContent = svgElement("g");
leftContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftContent);

const rightContent = svgElement("g");
rightContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightContent);

const contents = [leftContent, rightContent];

container.appendChild(svg);
document.body.appendChild(container);

function panelAt(x, y, color, connectivity = 0, jiggle = false) {
  const element = svgElement("use");
  if (color === GARBAGE) {
    element.setAttribute("href", jiggle ? "#jiggling-garbage": "#garbage");
  } else {
    element.setAttribute("href", `#panel${connectivity}`);
  }
  element.setAttribute("x", x + 0.5);
  element.setAttribute("y", y + 0.5);
  element.setAttribute("fill", FILLS[color]);
  element.setAttribute("stroke", STROKES[color]);
  element.setAttribute("stroke-width", STROKE_WIDTH);
  if (color === GARBAGE) {
    return element;
  }
  const group = svgElement("g");
  group.appendChild(element);
  const glyph = svgElement("use");
  glyph.setAttribute("x", x + 0.5);
  glyph.setAttribute("y", y + 0.5);
  glyph.setAttribute("fill", STROKES[color]);
  if (color === RED) {
    glyph.setAttribute("href", jiggle ? "#jiggling-heart" : "#heart");
  } else if (color === GREEN) {
    glyph.setAttribute("href", jiggle ? "#jiggling-circle" : "#small-circle");
  } else if (color === YELLOW) {
    glyph.setAttribute("href", jiggle ? "#jiggling-star" : "#small-star");
  } else if (color === BLUE) {
    glyph.setAttribute("href", jiggle ? "#jiggling-moon" : "#small-moon");
  } else if (color === PURPLE) {
    glyph.setAttribute("href", jiggle ? "#jiggling-diamond" : "#small-diamond");
  }
  group.appendChild(glyph);
  return group;
}

function renderGame() {
  const gameState = game.state;

  for (let i = 0; i < 2; ++i) {
    const currentTime = svg.getCurrentTime();
    const newChildren = [];

    const garbageDisplay = combinedGarbageDisplay(gameState[i].pendingGarbage, gameState[i].lateGarbage);
    garbageDisplay.forEach((symbol, x) => {
      if (symbol === "rock") {
        symbol = "spade";
      } else if (symbol === "crown") {
        symbol = "diamond";
      }
      const glyph = svgElement("use");
      glyph.setAttribute("href", "#" + symbol);
      glyph.setAttribute("fill", FILLS[GARBAGE]);
      glyph.setAttribute("stroke", STROKES[GARBAGE]);
      glyph.setAttribute("stroke-width", STROKE_WIDTH);
      glyph.setAttribute("x", x + 0.5);
      glyph.setAttribute("y", -0.9);
      newChildren.push(glyph);
    });

    const previewBag = gameState[i].visibleBag.slice(-4);
    newChildren.push(panelAt(WIDTH + 0.5, 1, previewBag[0]));
    newChildren.push(panelAt(WIDTH + 0.5, 0, previewBag[1]));
    newChildren.push(panelAt(WIDTH + 1, 3.2, previewBag[2]));
    newChildren.push(panelAt(WIDTH + 1, 2.2, previewBag[3]));

    for (let y = 0; y < LIFE_HEIGHT; ++y) {
      for (let x = 0; x < WIDTH; ++x) {
        const arrayIndex = x + (y + GHOST_Y + 1) * WIDTH;
        const index = gameState[i].screen.grid[arrayIndex];
        if (index >= 0) {
          if (gameState[i].screen.sparking[arrayIndex]) {
            // Garbage sparks are invisible even if they still support the panels above.
            if (index !== GARBAGE) {
              const sparks = svgElement("use");
              sparks.setAttribute("href", "#sparks");
              sparks.setAttribute("x", x + 0.5);
              sparks.setAttribute("y", y + 0.5);
              sparks.setAttribute("fill", STROKES[index]);
              newChildren.push(sparks);
            }
          } else {
            const panel = panelAt(x, y, index, gameState[i].screen.connectivity[arrayIndex], gameState[i].screen.jiggling[arrayIndex]);
            if (gameState[i].screen.falling[arrayIndex]) {
              const animation = svgElement("animateTransform");
              animation.setAttribute("attributeName", "transform");
              animation.setAttribute("attributeType", "XML");
              animation.setAttribute("type", "translate");
              animation.setAttribute("from", "0 0");
              animation.setAttribute("to", "0 1");
              animation.setAttribute("begin", `${currentTime}s`);
              animation.setAttribute("dur", `${1/FRAME_RATE}s`);
              animation.setAttribute("repeatCount", 1);
              animation.setAttribute("fill", "freeze");

              panel.appendChild(animation);
            }

            newChildren.push(panel);
          }
        }
      }
    }
    contents[i].replaceChildren(...newChildren);

    const scoreLabel = svgElement("text");
    scoreLabel.setAttribute("y", LIFE_HEIGHT+0.8);
    scoreLabel.classList.add("score-label");
    scoreLabel.textContent = "Score:";
    contents[i].appendChild(scoreLabel);

    const score = svgElement("text");
    score.classList.add("score");
    score.setAttribute("y", LIFE_HEIGHT+0.8);
    score.setAttribute("dx", scoreLabel.getBBox().width + 0.1);
    score.textContent = gameState[i].score;
    contents[i].appendChild(score);

  }
}

let gameAge = 0;

let start;
let frameId;

function draw(timeStamp) {
  if (start === undefined) {
    start = timeStamp;
  }
  const elapsed = timeStamp - start;
  const intendedAge = Math.min(FRAME_RATE * elapsed / 1000, gameAge + FRAME_RATE);

  const needsRedraw = (gameAge < intendedAge);

  while (gameAge < intendedAge) {
    game.tick();
    gameAge++;

    // TODO: Worker thread for maxDroplet2.
    if (!game.games[0].busy) {
      const {x1, y1, orientation} = MOVES[Math.floor(Math.random() * MOVES.length)];
      game.play(0, x1, y1, orientation);
    }

    if (!game.games[1].busy) {
      const simpleGame = game.toSimpleGame(1);
      const {move, score} = maxDropletStrategy1(simpleGame);
      const {x1, y1, orientation} = MOVES[move];
      game.play(1, x1, y1, orientation);
    }
  }
  if (needsRedraw) {
    renderGame();
  }

  frameId = window.requestAnimationFrame(draw);
}

frameId = window.requestAnimationFrame(draw);

const panicButton = document.createElement("button");
panicButton.onclick = () => window.cancelAnimationFrame(frameId);
panicButton.textContent = "stop";
document.body.appendChild(panicButton);

</script>
</head>
<body></body>
</html>
