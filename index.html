<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    body {
      background-color: #223;
    }
    .container {
      user-select: none;
    }
  </style>
<script type="module">
import { MultiplayerGame, RED, GREEN, YELLOW, BLUE, PURPLE, WIDTH, LIFE_HEIGHT, GHOST_Y, MOVES, GARBAGE, combinedGarbageDisplay, maxDropletStrategy1 } from "./build/index.js";
import { transformPath, svgElement, makeDefs } from "./build/svgdefs.js";
import { createSoftSquare, arpegiate, PingPongDelay, edArpeggio } from "./build/sound.js";

// TODO: Make right clicks swap the panels in cursor
// TODO: Semi-ignite the first group during input
// TODO: Easy/no CPU
// TODO: Responsive layout
// TODO: Landing sound FX
// TODO: All clear fanfare
// TODO: Diffing to reduce render load
// TODO: Audio worklet for less glitchy FX
// TODO: Touch interface
// TODO: Make the CPU avoid topouts
// TODO: Remove stop button
// TODO: Game overs and restarts
// TODO: Track wins

const strategyWorker = new Worker("./build/worker.js");
let waitingForStrategy = false;

const FRAME_RATE = 30;

// 'RGYBPN'
const STROKES = ["#d22", "#2d2", "#dd2", "#22e", "#d2c", "rgba(20, 160, 160, 0.88)"];
const FILLS = ["#922", "#292", "#882", "#229", "#828", "rgba(30, 255, 255, 0.94)"];
const IGNITION_FILL = "#eed";
const STROKE_WIDTH = 0.15;

const CHAIN_FILL = "rgba(255, 250, 240, 0.2)";
const CHAIN_BORDER = "rgba(50, 40, 30, 0.4)";
const CHAIN_BORDER_WIDTH = 0.1;

const LEFT_SCREEN_X = 2;
const LEFT_SCREEN_Y = 2;
const RIGHT_SCREEN_X = 11;
const RIGHT_SCREEN_Y = LEFT_SCREEN_Y;

const NUM_CARD_INDICES = 4;

const game = new MultiplayerGame();

const nextChainCards = [0, 2];
const ignitionCenters = [[0, 0], [0, 0]];
const screenColors = [
  Array(WIDTH * LIFE_HEIGHT).fill(-1),
  Array(WIDTH * LIFE_HEIGHT).fill(-1)
];

document.body.appendChild(makeDefs());

const container = document.createElement("div");
container.classList.add("container");
document.body.appendChild(container);

function juggleCards(cardIndex) {
  return [1, 0, 3, 2][cardIndex];
}

const svg = svgElement("svg");
svg.setAttribute("width", "95vh");
svg.setAttribute("height", "95vh");
svg.setAttribute("viewBox", "0 0 19 19");
container.appendChild(svg);

// Styles
const style = svgElement("style");
style.textContent = (
  ".score-label {font: bold 0.7px sans-serif; fill:azure;} " +
  ".score {font: bold 0.7px monospace; fill:azure;} " +
  ".all-clear {font: bold 1px sans-serif; fill:aliceblue; stroke:cornflowerblue; stroke-width:0.035px; stroke-linejoin:round; stroke-linecap:round;} "+
  ".chain {font: bold 0.8px sans-serif; fill:#fee; stroke:rgba(85, 83, 80, 0.7); stroke-width:0.04px;} "
);
svg.appendChild(style);

// Visible elements
const leftGhostContent = svgElement("g");
leftGhostContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftGhostContent);

const rightGhostContent = svgElement("g");
rightGhostContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightGhostContent);

const ghostContents = [leftGhostContent, rightGhostContent];

const leftScreen = svgElement("use");
leftScreen.setAttribute("href", "#screen");
leftScreen.setAttribute("x", LEFT_SCREEN_X);
leftScreen.setAttribute("y", LEFT_SCREEN_Y);
svg.appendChild(leftScreen);

const rightScreen = svgElement("use");
rightScreen.setAttribute("href", "#screen");
rightScreen.setAttribute("x", RIGHT_SCREEN_X);
rightScreen.setAttribute("y", RIGHT_SCREEN_Y);
svg.appendChild(rightScreen);

const allClearLabels = [];
for (let i = 0; i < 2; ++i) {
  const allClearPath = svgElement("path");
  allClearPath.setAttribute("id", `all-clear-path-${i}`);
  if (i === 0) {
    allClearPath.setAttribute("d", `M ${LEFT_SCREEN_X+0.9} ${LEFT_SCREEN_Y+2} q 2 -0.5 4 0`);
  } else {
    allClearPath.setAttribute("d", `M ${RIGHT_SCREEN_X+0.9} ${RIGHT_SCREEN_Y+2} q 2 -0.5 4 0`);
  }
  allClearPath.setAttribute("fill", "none");
  svg.appendChild(allClearPath);
  const text = svgElement("text");
  const textPath = svgElement("textPath");
  textPath.setAttribute("href", `#all-clear-path-${i}`);
  text.appendChild(textPath);
  text.classList.add("all-clear");
  svg.appendChild(text);

  allClearLabels.push(textPath);
}

const leftContent = svgElement("g");
leftContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftContent);

const rightContent = svgElement("g");
rightContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightContent);

const contents = [leftContent, rightContent];

const chainBoxes = [];
const chainTexts = [];
const chainAnimations = [];
const chains = [];
for (let i = 0; i < NUM_CARD_INDICES; ++i) {
  const chain = svgElement("g");
  chain.setAttribute("opacity", 0);
  const chainBox = svgElement("rect");
  chainBox.setAttribute("rx", 0.2);
  chainBox.setAttribute("ry", 0.2);
  chainBox.setAttribute("height", 1);
  chainBox.setAttribute("fill", CHAIN_FILL);
  chainBox.setAttribute("stroke", CHAIN_BORDER);
  chainBox.setAttribute("stroke-width", CHAIN_BORDER_WIDTH);
  const chainText = svgElement("text");
  chainText.classList.add("chain");
  chainText.textContent = "0-Chain";
  chainText.setAttribute("x", 0.2);
  chainText.setAttribute("y", 0.75);
  chain.appendChild(chainBox);
  chain.appendChild(chainText);

  const animation = svgElement("animate");
  animation.setAttribute("attributeName", "opacity");
  animation.setAttribute("values", "0");
  animation.setAttribute("begin", "0s");
  animation.setAttribute("dur", "1.3s");
  animation.setAttribute("repeatCount", "1");
  animation.setAttribute("fill", "freeze");
  chain.appendChild(animation);

  chainBoxes.push(chainBox);
  chainTexts.push(chainText);
  chainAnimations.push(animation);
  chains.push(chain);

  svg.appendChild(chain);
}

function panelSymbol(color, jiggle = false) {
  if (color === RED) {
    return jiggle ? "#jiggling-heart" : "#heart";
  } else if (color === GREEN) {
    return jiggle ? "#jiggling-circle" : "#small-circle";
  } else if (color === YELLOW) {
    return jiggle ? "#jiggling-star" : "#small-star";
  } else if (color === BLUE) {
    return jiggle ? "#jiggling-moon" : "#small-moon";
  } else if (color === PURPLE) {
    return jiggle ? "#jiggling-diamond" : "#small-diamond";
  }
}

function panelAt(x, y, color, connectivity = 0, jiggle = false, ignited = false) {
  const element = svgElement("use");
  if (color === GARBAGE) {
    element.setAttribute("href", jiggle ? "#jiggling-garbage": "#garbage");
  } else {
    element.setAttribute("href", `#panel${connectivity}`);
  }
  element.setAttribute("x", x + 0.5);
  element.setAttribute("y", y + 0.5);
  element.setAttribute("fill", ignited ? IGNITION_FILL : FILLS[color]);
  element.setAttribute("stroke", STROKES[color]);
  element.setAttribute("stroke-width", STROKE_WIDTH);
  if (color === GARBAGE) {
    return element;
  }
  const group = svgElement("g");
  group.appendChild(element);
  const glyph = svgElement("use");
  glyph.setAttribute("x", x + 0.5);
  glyph.setAttribute("y", y + 0.5);
  glyph.setAttribute("fill", STROKES[color]);
  glyph.setAttribute("href", panelSymbol(color, jiggle));
  group.appendChild(glyph);
  return group;
}

function renderGame() {
  for (let cardIndex = 0; cardIndex < NUM_CARD_INDICES; ++cardIndex) {
    chainBoxes[cardIndex].setAttribute("width", chainTexts[cardIndex].getBBox().width + 0.4);
  }

  const gameState = game.state;

  for (let i = 0; i < 2; ++i) {
    const currentTime = svg.getCurrentTime();

    const newGhostChildren = [];
    for (let x = 0; x < WIDTH; ++x) {
      const arrayIndex = x + GHOST_Y * WIDTH;
      const color = gameState[i].screen.grid[arrayIndex];
      if (color >= 0) {
        const ghostPanel = svgElement("use");
        if (color === GARBAGE) {
          ghostPanel.setAttribute("href", "#garbage");
        } else {
          ghostPanel.setAttribute("href", "#panel0");
        }
        ghostPanel.setAttribute("x", x + 0.5);
        ghostPanel.setAttribute("y", -0.5);
        ghostPanel.setAttribute("fill", "none");
        ghostPanel.setAttribute("stroke", STROKES[color]);
        ghostPanel.setAttribute("stroke-width", STROKE_WIDTH * 0.5);
        ghostPanel.setAttribute("stroke-dasharray", "0.1 0.108");
        ghostPanel.setAttribute("stroke-linecap", "round");
        ghostPanel.setAttribute("stroke-linejoin", "round");
        ghostPanel.setAttribute("mask", "url(#fade-mask)");
        newGhostChildren.push(ghostPanel);
      }
    }
    ghostContents[i].replaceChildren(...newGhostChildren);

    allClearLabels[i].textContent = gameState[i].allClearBonus ? "All Clear" : "";

    const newChildren = [];

    const garbageDisplay = combinedGarbageDisplay(gameState[i].pendingGarbage, gameState[i].lateGarbage);
    garbageDisplay.forEach((symbol, x) => {
      if (symbol === "rock") {
        symbol = "spade";
      } else if (symbol === "crown") {
        symbol = "diamond";
      }
      const glyph = svgElement("use");
      glyph.setAttribute("href", "#" + symbol);
      glyph.setAttribute("fill", FILLS[GARBAGE]);
      glyph.setAttribute("stroke", STROKES[GARBAGE]);
      glyph.setAttribute("stroke-width", STROKE_WIDTH);
      glyph.setAttribute("x", x + 0.5);
      glyph.setAttribute("y", -1);
      newChildren.push(glyph);
    });

    const previewBag = gameState[i].visibleBag.slice(-4);
    newChildren.push(panelAt(WIDTH + 0.5, 1, previewBag[0]));
    newChildren.push(panelAt(WIDTH + 0.5, 0, previewBag[1]));
    newChildren.push(panelAt(WIDTH + 1, 3.2, previewBag[2]));
    newChildren.push(panelAt(WIDTH + 1, 2.2, previewBag[3]));

    let numIgnitions = 0;
    let ignitionX = 0;
    let ignitionY = 0;

    for (let y = 0; y < LIFE_HEIGHT; ++y) {
      for (let x = 0; x < WIDTH; ++x) {
        const arrayIndex = x + (y + GHOST_Y + 1) * WIDTH;
        const color = gameState[i].screen.grid[arrayIndex];
        screenColors[i][x + y * WIDTH] = color;
        if (color >= 0) {
          const screen = gameState[i].screen;
          if (screen.ignited[arrayIndex]) {
            numIgnitions++;
            ignitionX += x;
            ignitionY += y;
          }

          if (screen.sparking[arrayIndex]) {
            // Garbage sparks are invisible even if they still support the panels above.
            if (color !== GARBAGE) {
              const sparks = svgElement("use");
              sparks.setAttribute("href", "#sparks");
              sparks.setAttribute("x", x + 0.5);
              sparks.setAttribute("y", y + 0.5);
              sparks.setAttribute("fill", STROKES[color]);
              newChildren.push(sparks);
            }
          } else {
            const panel = panelAt(x, y, color, screen.connectivity[arrayIndex], screen.jiggling[arrayIndex], screen.ignited[arrayIndex]);
            if (screen.falling[arrayIndex]) {
              const animation = svgElement("animateTransform");
              animation.setAttribute("attributeName", "transform");
              animation.setAttribute("attributeType", "XML");
              animation.setAttribute("type", "translate");
              animation.setAttribute("from", "0 0");
              animation.setAttribute("to", "0 1");
              animation.setAttribute("begin", `${currentTime}s`);
              animation.setAttribute("dur", `${1/FRAME_RATE}s`);
              animation.setAttribute("repeatCount", 1);
              animation.setAttribute("fill", "freeze");

              panel.appendChild(animation);
            }

            newChildren.push(panel);
          }
        }
      }
    }

    if (numIgnitions) {
      ignitionCenters[i][0] = ignitionX / numIgnitions;
      ignitionCenters[i][1] = ignitionY / numIgnitions;
    }

    contents[i].replaceChildren(...newChildren);

    const scoreLabel = svgElement("text");
    scoreLabel.setAttribute("y", LIFE_HEIGHT+0.8);
    scoreLabel.classList.add("score-label");
    scoreLabel.textContent = "Score:";
    contents[i].appendChild(scoreLabel);

    const score = svgElement("text");
    score.classList.add("score");
    score.setAttribute("y", LIFE_HEIGHT+0.8);
    score.setAttribute("dx", scoreLabel.getBBox().width + 0.1);
    score.textContent = gameState[i].score;
    contents[i].appendChild(score);

  }
}

let gameAge = 0;

let start;
let frameId;

function draw(timeStamp) {
  if (start === undefined) {
    start = timeStamp;
  }
  const elapsed = timeStamp - start;
  const intendedAge = Math.min(FRAME_RATE * elapsed / 1000, gameAge + FRAME_RATE);

  const needsRedraw = (gameAge < intendedAge);

  while (gameAge < intendedAge) {
    const tickResults = game.tick();
    gameAge++;

    for (let i = 0; i < 2; ++i) {
      if (tickResults[i].didClear) {
        const cardIndex = nextChainCards[i];

        const x = i === 0 ? LEFT_SCREEN_X : RIGHT_SCREEN_X;
        const y = i === 0 ? LEFT_SCREEN_Y : RIGHT_SCREEN_Y;
        chains[cardIndex].setAttribute("transform", `translate(${x + ignitionCenters[i][0]}, ${y + ignitionCenters[i][1] - 0.5})`);
        chains[cardIndex].setAttribute("opacity", 0.1);

        chainAnimations[cardIndex].setAttribute("begin", `${svg.getCurrentTime()}s`);
        chainAnimations[cardIndex].setAttribute("values", "0.1;1;0.95;0.9;0.8;0.7;0");

        const chainNumber = tickResults[i].chainNumber;
        if (chainNumber > 0) {
          chainTexts[cardIndex].textContent = `${chainNumber}-Chain`;
          playSoundFX(i, chainNumber);
        }
        nextChainCards[i] = juggleCards(cardIndex);
      }
    }

    // User input for the left screen.
    if (tickResults[0].busy) {
      disableUserInput();
    } else {
      enableUserInput();
    }

    // Worker thread for maxDroplet2.
    if (!tickResults[1].busy && !waitingForStrategy) {
      waitingForStrategy = true;
      strategyWorker.postMessage(game.toSimpleGame(1));
    }
  }
  if (needsRedraw) {
    renderGame();
  }

  frameId = window.requestAnimationFrame(draw);
}

// Pre-render once.
renderGame();

// Worker thread for maxDroplet2.
strategyWorker.onmessage = (e) => {
  const {move, score} = e.data;
  const {x1, y1, orientation} = MOVES[move];
  if (game.toSimpleGame(1).availableMoves.length) {
    game.play(1, x1, y1, orientation);
  }
  waitingForStrategy = false;
};

// User interface
// Please note that orbit distances less than 0.5 would need updates to the second panel during cursor movement.
const MIN_ORBIT_DISTANCE = 0.5;
const MAX_ORBIT_DISTANCE = 7;
let mainPanelLocked = false;
let mainGridX = 2;
let mainGridY = 0;
let secondDeltaX = 0;
let secondDeltaY = -1;

const mainPanel = svgElement("use");
mainPanel.setAttribute("href", "#panel0");
mainPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
mainPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
mainPanel.setAttribute("fill", "none");
mainPanel.setAttribute("stroke", STROKES[game.games[0].visibleBag[0]]);
mainPanel.setAttribute("stroke-width", STROKE_WIDTH);
svg.appendChild(mainPanel);

const mainGlyph = svgElement("use");
mainGlyph.setAttribute("fill", "none");
mainGlyph.setAttribute("href", panelSymbol(game.games[0].visibleBag[0]));
svg.appendChild(mainGlyph);

// Extra indicator when cursor overlaps with a similar color
const mainPanelHelper = svgElement("use");
mainPanelHelper.setAttribute("href", "#panel0");
mainPanelHelper.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
mainPanelHelper.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
mainPanelHelper.setAttribute("fill", "none");
mainPanelHelper.setAttribute("stroke", "none");
mainPanelHelper.setAttribute("stroke-width", STROKE_WIDTH * 0.4);
svg.appendChild(mainPanelHelper);

const secondPanel = svgElement("use");
secondPanel.setAttribute("href", "#panel0");
secondPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + secondDeltaX + 0.5);
secondPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + secondDeltaY + 0.5);
secondPanel.setAttribute("fill", "none");
secondPanel.setAttribute("stroke", STROKES[game.games[0].visibleBag[1]]);
secondPanel.setAttribute("stroke-width", STROKE_WIDTH * 0.5);
svg.appendChild(secondPanel);

const secondGlyph = svgElement("use");
secondGlyph.setAttribute("fill", "none");
secondGlyph.setAttribute("href", panelSymbol(game.games[0].visibleBag[1]));
svg.appendChild(secondGlyph);

function disableUserInput() {
  mainPanel.setAttribute("fill", "none");
  mainPanel.setAttribute("stroke", "none");
  mainGlyph.setAttribute("fill", "none");
  mainPanelHelper.setAttribute("fill", "none");
  mainPanelHelper.setAttribute("stroke", "none");
  secondPanel.setAttribute("stroke", "none");
  secondGlyph.setAttribute("fill", "none");
}

function helpMainPanel() {
  if (screenColors[0][mainGridX + mainGridY * WIDTH] === game.games[0].visibleBag[0]) {
    mainPanelHelper.setAttribute("fill", "rgba(255, 255, 255, 0.1)");
    mainPanelHelper.setAttribute("stroke", "white");
  } else {
    mainPanelHelper.setAttribute("fill", "none");
    mainPanelHelper.setAttribute("stroke", "none");
  }
}

function enableUserInput() {
  mainPanel.setAttribute("stroke", STROKES[game.games[0].visibleBag[0]]);
  secondPanel.setAttribute("stroke", STROKES[game.games[0].visibleBag[1]]);
  helpMainPanel();
}

function snapToGrid(x, y) {
  const gridX = Math.max(0, Math.min(WIDTH - 1, Math.floor(x - LEFT_SCREEN_X)));
  const gridY = Math.max(-1, Math.min(LIFE_HEIGHT - 1, Math.floor(y - LEFT_SCREEN_Y)));
  return {gridX, gridY};
}

function updatePanelPositions() {
  mainPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
  mainPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
  mainPanelHelper.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
  mainPanelHelper.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
  secondPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + secondDeltaX + 0.5);
  secondPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + secondDeltaY + 0.5);
  helpMainPanel();
}

function updateGlyphPositions() {
  mainGlyph.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
  mainGlyph.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
  secondGlyph.setAttribute("x", LEFT_SCREEN_X + mainGridX + secondDeltaX + 0.5);
  secondGlyph.setAttribute("y", LEFT_SCREEN_Y + mainGridY + secondDeltaY + 0.5);
}

function kickCursor() {
  while (mainGridX + secondDeltaX < 0) {
    mainGridX++;
  }
  while (mainGridX + secondDeltaX >= WIDTH) {
    mainGridX--;
  }
  while (mainGridY + secondDeltaY >= LIFE_HEIGHT) {
    mainGridY--;
  }
}

let lastCursorX = 0;
let lastCursorY = 0;
function moveCursor(x, y) {
  lastCursorX = x;
  lastCursorY = y;
  const {gridX, gridY} = snapToGrid(x, y);
  mainGridX = gridX;
  mainGridY = gridY;
  kickCursor();
  updatePanelPositions();
}

function lockMainPanel(x, y) {
  if (mainPanelLocked || game.games[0].busy) {
    return;
  }
  moveCursor(x, y);

  // Kick the main panel up for a less cluttered UX.
  mainGridY = game.games[0].screen.kickPuyo(mainGridX, mainGridY + GHOST_Y + 1) - GHOST_Y - 1;

  updatePanelPositions();
  updateGlyphPositions();

  mainPanelLocked = true;

  mainPanel.setAttribute("fill", FILLS[game.games[0].visibleBag[0]]);

  mainGlyph.setAttribute("fill", STROKES[game.games[0].visibleBag[0]]);
  mainGlyph.setAttribute("href", panelSymbol(game.games[0].visibleBag[0]));

  secondGlyph.setAttribute("fill", STROKES[game.games[0].visibleBag[1]]);
  secondGlyph.setAttribute("href", panelSymbol(game.games[0].visibleBag[1]));
}

function unlockMainPanel(x, y) {
  mainPanelLocked = false;
  secondDeltaX = 0;
  secondDeltaY = -1;
  moveCursor(x, y);

  mainPanel.setAttribute("fill", "none");
  mainGlyph.setAttribute("fill", "none");
  secondGlyph.setAttribute("fill", "none");
}

function orbitSecondPanel(x, y) {
  const viewBoxX = LEFT_SCREEN_X + mainGridX + 0.5;
  const viewBoxY = LEFT_SCREEN_Y + mainGridY + 0.5;

  const dx = x - viewBoxX;
  const dy = y - viewBoxY;
  const distance = Math.hypot(dx, dy);

  let hintDeltaX = secondDeltaX;
  let hintDeltaY = secondDeltaY;

  if (distance > MAX_ORBIT_DISTANCE) {
    unlockMainPanel(x, y);
  } else if (distance > MIN_ORBIT_DISTANCE) {
    if (Math.abs(dx) > Math.abs(dy)) {
      secondDeltaX = Math.sign(dx);
      secondDeltaY = dy / Math.abs(dx);

      hintDeltaX = secondDeltaX;
      hintDeltaY = 0;
    } else {
      secondDeltaX = dx / Math.abs(dy);
      secondDeltaY = Math.sign(dy);

      hintDeltaX = 0;
      hintDeltaY = secondDeltaY;
    }

    // Main panel locked, cannot kick.
    if ((mainGridX + secondDeltaX < 0) || (mainGridX + secondDeltaX >= WIDTH)) {
      secondDeltaY = Math.sign(secondDeltaY) || 1;
      hintDeltaX = 0;
      hintDeltaY = secondDeltaY;
    }
    if (mainGridY + secondDeltaY >= LIFE_HEIGHT) {
      secondDeltaX = Math.sign(secondDeltaX) || 1;
      hintDeltaX = secondDeltaX;
      hintDeltaY = 0;
    }

    secondPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + secondDeltaX + 0.5);
    secondPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + secondDeltaY + 0.5);

    secondGlyph.setAttribute("x", LEFT_SCREEN_X + mainGridX + hintDeltaX + 0.5);
    secondGlyph.setAttribute("y", LEFT_SCREEN_Y + mainGridY + hintDeltaY + 0.5);
  }

  return {hintDeltaX, hintDeltaY};
}

function getOrientation() {
  if (secondDeltaY === -1) {
    return 0;
  }
  if (secondDeltaY === 1) {
    return 2;
  }
  if (secondDeltaX === -1) {
    return 1;
  }
  if (secondDeltaX === 1) {
    return 3;
  }
  return 0;
}

function setOrientation(orientation) {
  orientation &= 3;
  if (orientation === 0) {
    secondDeltaX = 0;
    secondDeltaY = -1;
  } else if (orientation === 1) {
    secondDeltaX = -1;
    secondDeltaY = 0;
  } else if (orientation === 2) {
    secondDeltaX = 0;
    secondDeltaY = 1;
  } else if (orientation === 3) {
    secondDeltaX = 1;
    secondDeltaY = 0;
  }
  // Kick or unkick as necessary.
  moveCursor(lastCursorX, lastCursorY);
}

// TODO: Give extra points for playing lower
function commitMove(x, y) {
  if (game.games[0].busy || !mainPanelLocked) {
    return;
  }
  // Commit hint
  const {hintDeltaX, hintDeltaY} = orbitSecondPanel(x, y);
  secondDeltaX = hintDeltaX;
  secondDeltaY = hintDeltaY;

  game.play(0, mainGridX, mainGridY + GHOST_Y + 1, getOrientation());

  mainPanelLocked = false;
  secondDeltaX = 0;
  secondDeltaY = -1;

  kickCursor();
  updatePanelPositions();
  disableUserInput();
}

// Sound FX
const AUDIO_LAG = 0.01;  // Make audio laggy but less clicky.
const MIRACLE_HEXAD_RATIOS = [1.12373, 1.24848, 1.42557, 1.60195, 1.75156];
const MIRACLE_CHORD = [830];
for (let i = 0; i < 5; ++i) {
  MIRACLE_CHORD.push(MIRACLE_HEXAD_RATIOS[i] * 830);
}
for (let i = 3; i >= 0; --i) {
  MIRACLE_CHORD.push(MIRACLE_HEXAD_RATIOS[i] * 1660);
}

const ARPEGGIOS = [
  edArpeggio([0, 1, 2, 3], 7, 2, 430),  // 7-edo cluster, slightly lower.
  edArpeggio([0, 2, 4, 6]),  // Whole-tone cluster.
  edArpeggio([0, 1, 2, 3], 5, 2, 453),  // 5-edo cluster, slightly higher.
  edArpeggio([1, 4, 7, 10]),  // Fully diminished chord.
  [494, 494 * 6/5, 494 * 3/2, 494 * 9 / 5],  // Just minor seventh chord.
  [523, 523 * 5/4, 523 * 6/4, 523 * 7/4],  // Harmonic seventh chord.
  edArpeggio([4, 8, 12, 16]),  // Augmented chord.
  [587, 587 * 4/3, 587 * 16/9, 587 * 64/27],  // Stack of just fourths.
  [622, 622 * 11/8, 622 * 121/60, 622 * 1331/512],  // Stack of just superfourths.
  [659, 659 * 3/2, 659 * 9/4, 659 * 27/8],  // Stack of just fifths.
  [6660 / 9, 6660 / 8, 6660 / 7, 6660 / 6, 6660 / 5, 6660 / 4, 6660 / 3],  // Subharmonics 9-3.
  edArpeggio([0, 1, 3, 5, 7, 11, 13], 9, 2, 698),  // Prime steps of 9-edo.
  [8624 / 11, 8624 / 10, 8624 / 9, 8624 / 8, 8624 / 7, 8624 / 6, 8624 / 5, 8624 / 4],  // Subharmonics 11-4.
  MIRACLE_CHORD,  // Essentially tempered Miracle hexad.
  [880, 880 * 13/10, 880 * 15/10, 880 * 16/10, 880 * 19/10, 880 * 18/10, 880 * 25/10, 880 * 24/10],  // Supermajor chord with otonal extensions.
  edArpeggio([0, 7, 13, 40, 36, 34, 20, 26, 30], 23, 2, 932),  // Anti-minor chord with random extensions.
  [2303, 1523, 3754, 2910, 3312, 2563, 3259, 1061, 2888],  // Completely random chord.
  [1209, 1336, 1477, 1633, 697, 770, 852, 941],  // DTMF.
  edArpeggio([0, 2, 3, 5, 2, 2, -2, 0, 0, -12, 12, 12]),  // The Lick.
];

let context;
const oscillators = [];
const envelopes = [];

function initialize() {
  if (frameId === undefined) {
    frameId = window.requestAnimationFrame(draw);
  }

  if (context === undefined) {
    context = new AudioContext({latencyHint: "interactive"});

    const delay = new PingPongDelay(context, 1);
    delay.delayTime = 0.1;
    delay.feedback = 0.4;
    delay.separation = 0.3;
    delay.connect(context.destination);

    for (let i = 0; i < 2; ++i) {
      // Give each player a voice through slight variation of the oscillators.
      let oscillator;
      if (i === 0) {
        oscillator = createSoftSquare(context);
      } else {
        oscillator = createSoftSquare(context, 0.085, 0.42, 0.06);
      }
      const envelope = context.createGain();

      oscillator.connect(envelope).connect(delay.destination)

      envelope.gain.setValueAtTime(0, context.currentTime);
      oscillator.start(context.currentTime);
      oscillators.push(oscillator);
      envelopes.push(envelope);
    }
  }
}

function playSoundFX(player, chainNumber) {
  if (context === undefined) {
    return;
  }
  // Try to resolve some glitches
  oscillators[player].frequency.cancelScheduledValues(context.currentTime);
  oscillators[player].frequency.setValueAtTime(ARPEGGIOS[chainNumber][0], context.currentTime);
  envelopes[player].gain.cancelScheduledValues(context.currentTime);

  const now = context.currentTime + AUDIO_LAG;
  envelopes[player].gain.setValueAtTime(0.45, now);
  envelopes[player].gain.exponentialRampToValueAtTime(1e-5, now + 3);
  arpegiate(oscillators[player], ARPEGGIOS[chainNumber - 1], now, now + 3);
}

const panicButton = document.createElement("button");
panicButton.onclick = () => {
  window.cancelAnimationFrame(frameId);
  if (context !== undefined) {
    oscillators.forEach(oscillator => oscillator.stop());
    context.suspend();
  }
}
panicButton.textContent = "stop";
document.body.appendChild(panicButton);

function viewBoxCoords(event) {
  const bounds = svg.getBoundingClientRect();
  const viewBox = svg.viewBox.baseVal;

  const x = (event.x - bounds.x) / bounds.width * viewBox.width;
  const y = (event.y - bounds.y) / bounds.height * viewBox.height;

  return {x, y};
}

document.addEventListener("mousemove", (e) => {
  const {x, y} = viewBoxCoords(e);
  if (mainPanelLocked) {
    orbitSecondPanel(x, y);
  } else {
    moveCursor(x, y);
  }
});

svg.addEventListener("mousedown", (e) => {
  initialize();
  if (e.button !== 0) {
    return;
  }
  const {x, y} = viewBoxCoords(e);
  lockMainPanel(x, y);
});

svg.addEventListener("mouseup", (e) => {
  if (e.button !== 0) {
    return;
  }
  const {x, y} = viewBoxCoords(e);
  commitMove(x, y);
});

document.addEventListener("keydown", (e) => {
  if (e.code === "KeyF") {
    setOrientation(getOrientation() - 1);
  } else if (e.code === "KeyD") {
    setOrientation(getOrientation() + 1);
  }
});

</script>
</head>
<body></body>
</html>
