<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    body {
      background-color: #223;
    }
  </style>
<script type="module">
import { MultiplayerGame, WIDTH, LIFE_HEIGHT, GHOST_Y, MOVES, combinedGarbageDisplay, maxDropletStrategy1 } from "./build/index.js";

// TODO: Responsive layout

const FRAME_RATE = 15;

// 'RGYBPN'
const FILLS = ["red", "lime", "yellow", "blue", "fuchsia", "cyan"];

const LEFT_SCREEN_X = 1;
const LEFT_SCREEN_Y = 2;
const RIGHT_SCREEN_X = 10;
const RIGHT_SCREEN_Y = LEFT_SCREEN_Y;

const SVG_NS = "http://www.w3.org/2000/svg";

const game = new MultiplayerGame();

const container = document.createElement("div");

function svgElement(qualifiedName) {
  return document.createElementNS(SVG_NS, qualifiedName);
}

const ARC_SCALE_FLAGS = [true, true, false, false, false, true, true];
const ARC_TRANSLATION_FLAGS = [false, false, false, false, false, true, true];
/**
 * Transform <path> element's definition by first re-scaling it and then translating the points.
 * NOTE: Likely incomplete and pretty much untested.
 */
function transformPath(d, scale = 1, dx = 0, dy = 0) {
  const transformed = [];
  let scaleFlags = [];
  let translationFlags = [];
  let horizontal = true;
  d.split(/\s+/).forEach(token => {
    let num = parseFloat(token);
    if (isNaN(num)) {
      transformed.push(token);
      horizontal = true;
      if (token.toUpperCase() === "A") {
        scaleFlags = [...ARC_SCALE_FLAGS];
        translationFlags = [...ARC_TRANSLATION_FLAGS];
      } else if (token.toUpperCase() === "V") {
        horizontal = false;
      }
      if (token === token.toLowerCase()) {
        translationFlags = Array(7).fill(false);
      }
    } else {
      let scaleFlag = true;
      let translationFlag = true;
      if (scaleFlags.length) {
        scaleFlag = scaleFlags.shift();
      }
      if (translationFlags.length) {
        translationFlag = translationFlags.shift();
      }
      if (scaleFlag) {
        num *= scale;
      }
      if (translationFlag) {
        num += (horizontal ? dx : dy);
        horizontal = !horizontal;
      }
      transformed.push(num.toString());
    }
  });
  return transformed.join(" ");
}

const svg = svgElement("svg");
svg.setAttribute("width", "95vh");
svg.setAttribute("height", "95vh");
svg.setAttribute("viewBox", "0 0 19 19");

// Styles
const style = svgElement("style");
style.textContent = ".score-label {font: bold 0.7px sans-serif; fill:azure;} .score {font: bold 0.7px monospace; fill:azure;}";
svg.appendChild(style);

// Defs
const defs = svgElement("defs");

const screenDef = svgElement("g");
screenDef.setAttribute("id", "screen");

const mainScreen = svgElement("rect");
mainScreen.setAttribute("width", WIDTH);
mainScreen.setAttribute("height", LIFE_HEIGHT);
mainScreen.setAttribute("fill", "none");
mainScreen.setAttribute("stroke", "black");
mainScreen.setAttribute("stroke-width", "0.06");
mainScreen.setAttribute("rx", "0.1");
mainScreen.setAttribute("ry", "0.1");
screenDef.appendChild(mainScreen);

const pieceBox = svgElement("polygon");
pieceBox.setAttribute("points", "0,0 1,0 1,2 1.5,2 1.5,4 0.5,4 0.5,2 0,2");
pieceBox.setAttribute("fill", "none");
pieceBox.setAttribute("stroke", "black");
pieceBox.setAttribute("stroke-width", "0.06");
pieceBox.setAttribute("transform", `translate(${WIDTH+0.5}, 0)`);
screenDef.appendChild(pieceBox);

defs.appendChild(screenDef);

const puyoDef = svgElement("circle");
puyoDef.setAttribute("id", "puyo");
puyoDef.setAttribute("r", 0.43);
puyoDef.setAttribute("stroke", "gainsboro");
puyoDef.setAttribute("stroke-width", "0.07");
defs.appendChild(puyoDef);

const sparksDef = svgElement("g");
sparksDef.setAttribute("id", "sparks");
for (let i = 0; i < 5; ++i) {
  const theta = 2 * Math.PI * i / 5;
  const spark = svgElement("circle");
  spark.setAttribute("cx", Math.cos(theta) * 0.3);
  spark.setAttribute("cy", Math.sin(theta) * 0.3);
  spark.setAttribute("r", 0.1);
  sparksDef.appendChild(spark);
}
const animation = svgElement("animateTransform");
animation.setAttribute("attributeName", "transform");
animation.setAttribute("type", "rotate");
animation.setAttribute("from", `0`);
animation.setAttribute("to", `360`);
animation.setAttribute("dur", "2s");
animation.setAttribute("repeatCount", "indefinite");
sparksDef.appendChild(animation);
defs.appendChild(sparksDef);

svg.appendChild(defs);

const heartDef = svgElement("path");
heartDef.setAttribute("id", "heart");
heartDef.setAttribute("d", "M 0 1 C 1.8 0 0 -1 0 0 C 0 -1 -1.8 0 0 1 Z");
defs.appendChild(heartDef);

const spadeDef = svgElement("path");
spadeDef.setAttribute("id", "spade");
const spadeD = "M 0.1 0 Q 0 0.6 0.4 0.8 H -0.4 Q 0 0.6 -0.1 0 C 0 1 -1.8 0 0 -1 C 1.8 0 0 1 0.1 0 Z";
spadeDef.setAttribute("d", transformPath(spadeD, 0.45));
defs.appendChild(spadeDef);

const moonDef = svgElement("path");
moonDef.setAttribute("id", "moon");
const moonD = "M 0 1 A 1.1 1.1 0 1 0 0 -1 A 1.04 1.04 0 0 1 0 1 Z";
moonDef.setAttribute("d", transformPath(moonD, 0.35, -0.15));
defs.appendChild(moonDef);

const diamondDef = svgElement("path");
diamondDef.setAttribute("id", "diamond");
const diamondD = "M 0 1 Q 0.6 0.6 1 0 Q 0.6 -0.6 0 -1 Q -0.6 -0.6 -1 0 Q -0.6 0.6 0 1 Z";
diamondDef.setAttribute("d", transformPath(diamondD, 0.4));
defs.appendChild(diamondDef);

const smallDef = svgElement("circle");
smallDef.setAttribute("id", "small");
smallDef.setAttribute("r", 0.2);
defs.appendChild(smallDef);

const largeDef = svgElement("circle");
largeDef.setAttribute("id", "large");
largeDef.setAttribute("r", 0.39);
defs.appendChild(largeDef);

const cometDef = svgElement("path");
cometDef.setAttribute("id", "comet");
const cometD = "M 0 1 A 1 1 0 0 1 0 -1 L 2 -1 L 0.5 -0.5 L 2.5 -0.1 L 0.3 0.3 L 1 1 Z";
cometDef.setAttribute("d", transformPath(cometD, 0.3, -0.15));
cometDef.setAttribute("transform", "rotate(-45)");
defs.appendChild(cometDef);

const starDef = svgElement("path");
starDef.setAttribute("id", "star");
let starD = "M 0 0.3";
const spikeDelta = Math.PI / 5;
for (let i = 1; i < 6; ++i) {
  const theta = 2 * Math.PI * i / 5;
  const x1 = 0.7 * Math.sin(theta - spikeDelta);
  const y1 = 0.7 * Math.cos(theta - spikeDelta);
  const x = 0.3 * Math.sin(theta);
  const y = 0.3 * Math.cos(theta);
  starD += ` Q ${x1} ${y1} ${x} ${y}`;
}
starD += " Z";
starDef.setAttribute("d", starD);
defs.appendChild(starDef);

// Visible elements
const leftScreen = svgElement("use");
leftScreen.setAttribute("href", "#screen");
leftScreen.setAttribute("x", LEFT_SCREEN_X);
leftScreen.setAttribute("y", LEFT_SCREEN_Y);
svg.appendChild(leftScreen);

const rightScreen = svgElement("use");
rightScreen.setAttribute("href", "#screen");
rightScreen.setAttribute("x", RIGHT_SCREEN_X);
rightScreen.setAttribute("y", RIGHT_SCREEN_Y);
svg.appendChild(rightScreen);

const leftContent = svgElement("g");
leftContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftContent);

const rightContent = svgElement("g");
rightContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightContent);

const contents = [leftContent, rightContent];

container.appendChild(svg);
document.body.appendChild(container);

function renderGame() {
  leftContent.replaceChildren();
  rightContent.replaceChildren();

  const gameState = game.state;

  for (let i = 0; i < 2; ++i) {
    const garbageDisplay = combinedGarbageDisplay(gameState[i].pendingGarbage, gameState[i].lateGarbage);
    garbageDisplay.forEach((symbol, x) => {
      if (symbol === "rock") {
        symbol = "spade";
      } else if (symbol === "crown") {
        symbol = "diamond";
      }
      const glyph = svgElement("use");
      glyph.setAttribute("href", "#" + symbol);
      glyph.setAttribute("fill", "cyan");
      glyph.setAttribute("stroke", "teal");
      glyph.setAttribute("stroke-width", 0.05);
      glyph.setAttribute("x", x + 0.5);
      glyph.setAttribute("y", -0.9);
      contents[i].appendChild(glyph);
    });

    const scoreLabel = svgElement("text");
    scoreLabel.setAttribute("y", LIFE_HEIGHT+0.8);
    scoreLabel.classList.add("score-label");
    scoreLabel.textContent = "Score:";
    contents[i].appendChild(scoreLabel);

    const score = svgElement("text");
    score.classList.add("score");
    score.setAttribute("y", LIFE_HEIGHT+0.8);
    score.setAttribute("dx", scoreLabel.getBBox().width + 0.1);
    score.textContent = gameState[i].score;
    contents[i].appendChild(score);

    const previewBag = gameState[i].visibleBag.slice(-4);
    const puyo0 = svgElement("use");
    puyo0.setAttribute("href", "#puyo");
    puyo0.setAttribute("x", WIDTH + 1);
    puyo0.setAttribute("y", 1.5);
    puyo0.setAttribute("fill", FILLS[previewBag[0]]);
    contents[i].appendChild(puyo0);
    const puyo1 = svgElement("use");
    puyo1.setAttribute("href", "#puyo");
    puyo1.setAttribute("x", WIDTH + 1);
    puyo1.setAttribute("y", 0.5);
    puyo1.setAttribute("fill", FILLS[previewBag[1]]);
    contents[i].appendChild(puyo1);
    const puyo2 = svgElement("use");
    puyo2.setAttribute("href", "#puyo");
    puyo2.setAttribute("x", WIDTH + 1.5);
    puyo2.setAttribute("y", 3.5);
    puyo2.setAttribute("fill", FILLS[previewBag[2]]);
    contents[i].appendChild(puyo2);
    const puyo3 = svgElement("use");
    puyo3.setAttribute("href", "#puyo");
    puyo3.setAttribute("x", WIDTH + 1.5);
    puyo3.setAttribute("y", 2.5);
    puyo3.setAttribute("fill", FILLS[previewBag[3]]);
    contents[i].appendChild(puyo3);

    for (let y = 0; y < LIFE_HEIGHT; ++y) {
      for (let x = 0; x < WIDTH; ++x) {
        const arrayIndex = x + (y + GHOST_Y + 1) * WIDTH;
        let index = gameState[i].screen.supported[arrayIndex];
        let falling = false;
        if (index < 0) {
          index = gameState[i].screen.unsupported[arrayIndex];
          falling = true;
        }
        if (index >= 0) {
          const puyo = svgElement("use");
          puyo.setAttribute("href", "#puyo");
          puyo.setAttribute("x", x + 0.5);
          puyo.setAttribute("y", y + 0.5);
          puyo.setAttribute("fill", FILLS[index]);

          if (falling) {
            const animation = svgElement("animate");
            animation.setAttribute("attributeName", "y");
            animation.setAttribute("to", y + 1.5);
            animation.setAttribute("begin", `${svg.getCurrentTime()}s`);
            animation.setAttribute("dur", `${1/FRAME_RATE}s`);
            animation.setAttribute("repeatCount", 1);
            animation.setAttribute("fill", "freeze");

            puyo.appendChild(animation);
          }

          contents[i].appendChild(puyo);
        }

        index = gameState[i].screen.sparks[arrayIndex];
        if (index >= 0) {
          const sparks = svgElement("use");
          sparks.setAttribute("href", "#sparks");
          sparks.setAttribute("x", x + 0.5);
          sparks.setAttribute("y", y + 0.5);
          sparks.setAttribute("fill", FILLS[index]);
          contents[i].appendChild(sparks);
        }
      }
    }
  }
}

let gameAge = 0;

let start;
let frameId;

function draw(timeStamp) {
  if (start === undefined) {
    start = timeStamp;
  }
  const elapsed = timeStamp - start;
  const intendedAge = Math.min(FRAME_RATE * elapsed / 1000, gameAge + FRAME_RATE);

  const needsRedraw = (gameAge < intendedAge);

  while (gameAge < intendedAge) {
    game.tick();
    gameAge++;

    if (!game.games[0].active) {
      const {x1, y1, orientation} = MOVES[Math.floor(Math.random() * MOVES.length)];
      game.play(0, x1, y1, orientation);
    }

    if (!game.games[1].active) {
      const simpleGame = game.toSimpleGame(1);
      const {move, score} = maxDropletStrategy1(simpleGame);
      const {x1, y1, orientation} = MOVES[move];
      game.play(1, x1, y1, orientation);
    }
  }
  if (needsRedraw) {
    renderGame();
  }

  frameId = window.requestAnimationFrame(draw);
}

frameId = window.requestAnimationFrame(draw);

</script>
</head>
<body></body>
</html>
