<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Italianno&display=swap');
    body {
      background-color: #223;
    }
    .container {
      margin: 0;
      padding: 0;
      user-select: none;
    }
  </style>
<script type="module">
import { MultiplayerGame, RED, GREEN, YELLOW, BLUE, PURPLE, WIDTH, VISIBLE_HEIGHT, HEIGHT, GHOST_Y, MOVES, GARBAGE, combinedGarbageDisplay, randomSeed, PASS } from "./build/index.js";
import { transformPath, svgElement, makeDefs } from "./build/svgdefs.js";
import { createSoftSquare, arpegiate, PingPongDelay, edArpeggio } from "./build/sound.js";

const FRAME_RATE = 30;

const strategyWorker = new Worker("./build/worker.js");
let waitingForStrategy = false;
let workerStrategy;
let workerGame;

const MAX_WORKER_ANTICIPATION = 5;
let workerAnticipation = 2;
let workerGameAge = 0;

const DIFFICULTIES = [
  {
    "label": "Easy",
    "botName": "random",
    "throttleFrames": FRAME_RATE * 4,
    "kickDown": false,
  },
  {
    "label": "Mid",
    "botName": "flex1",
    "throttleFrames": FRAME_RATE * 2,
    "kickDown": false,
  },
  {
    "label": "Hard",
    "botName": "flex2",
    "throttleFrames": 0,
    "kickDown": false,
  },
  {
    "label": "Brutal",
    "botName": "flex2",
    "throttleFrames": 0,
    "kickDown": true,
  },
];

let botName = DIFFICULTIES[0].botName;
let botThrottleFrames = 0;
let botInitialThrottleFrames = DIFFICULTIES[0].throttleFrames;
let botKickDown = DIFFICULTIES[0].kickDown;

let userMove;
let inputEnabled = true;

let startTime;
let frameId;

// 'RGYBPN'
const STROKES = ["#d22", "#2d2", "#dd2", "#22e", "#d2c", "rgba(20, 160, 160, 0.88)"];
const FILLS = ["#922", "#292", "#882", "#229", "#828", "rgba(30, 255, 255, 0.94)"];
const IGNITION_FILL = "#eed";
const STROKE_WIDTH = 0.15;

const CHAIN_FILL = "rgba(255, 250, 240, 0.2)";
const CHAIN_BORDER = "rgba(50, 40, 30, 0.4)";
const CHAIN_BORDER_WIDTH = 0.1;

const LEFT_SCREEN_X = 2;
const LEFT_SCREEN_Y = 2;
const RIGHT_SCREEN_X = 11;
const RIGHT_SCREEN_Y = LEFT_SCREEN_Y;

const NUM_CARD_INDICES = 4;

// Replayability
let replaying = false;
let seed = randomSeed();
let moves = [];
let replayIndex;

let wins = [0, 0];

let gameAge = 0;

let game = new MultiplayerGame(seed);
workerGame = game.clone();
// Does essentially nothing, but documents the intention.
for (let i = 0; i < workerAnticipation; ++i) {
  workerGame.tick();
  workerGameAge++;
}

const nextChainCards = [0, 2];
const ignitionCenters = [[0, 0], [0, 0]];
const screenColors = [
  Array(WIDTH * VISIBLE_HEIGHT).fill(-1),
  Array(WIDTH * VISIBLE_HEIGHT).fill(-1)
];
const preIgnitions = [
  Array(WIDTH * HEIGHT).fill(false),
  Array(WIDTH * HEIGHT).fill(false)
];
const gameOvers = [false, false];

const container = document.createElement("div");
container.classList.add("container");
document.body.appendChild(container);

const defs = makeDefs();
document.body.appendChild(defs);

function juggleCards(cardIndex) {
  return [1, 0, 3, 2][cardIndex];
}

const svg = svgElement("svg");
svg.setAttribute("width", "98vw");
svg.setAttribute("height", "95vh");
svg.setAttribute("viewBox", "0 0 20 17");
container.appendChild(svg);

// Styles
const style = svgElement("style");
style.textContent = (
  '.score-label {font: bold 0.7px "Arial", sans-serif; fill:azure;} ' +
  '.score {font: bold 0.7px "Lucida Console", monospace; fill:azure;} ' +
  '.all-clear {font: bold 1px "Arial", sans-serif; fill:aliceblue; stroke:cornflowerblue; stroke-width:0.035px; stroke-linejoin:round; stroke-linecap:round;} ' +
  '.game-over {font: bold 1.3px "Arial", sans-serif; fill:red; stroke:yellow; stroke-width:0.035px; stroke-linejoin:round; stroke-linecap:round;} ' +
  '.chain {font: bold 0.8px "Arial", sans-serif; fill:#fee; stroke:rgba(85, 83, 80, 0.7); stroke-width:0.04px;} ' +
  '.shadowed-text {font: bold 0.79px "Arial", sans-serif; dominant-baseline: middle; text-anchor: middle; filter:url(#shadow);} ' +
  '.difficulty-text {fill:#68a;} ' +
  '.difficulty-button {fill: #767; stroke: #a9a; stroke-width: 0.1;} ' +
  '.difficulty-text.active {fill:#bde;} ' +
  '.difficulty-button.active {fill:#ab9;} ' +
  '.title {font: 1.3px "Italianno", cursive;} ' +
  '.subtitle {font: italic 0.4px serif;} '
);
svg.appendChild(style);

// Visible elements
const leftGhostContent = svgElement("g");
leftGhostContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftGhostContent);

const rightGhostContent = svgElement("g");
rightGhostContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightGhostContent);

const ghostContents = [leftGhostContent, rightGhostContent];

const leftScreen = svgElement("use");
leftScreen.setAttribute("href", "#screen");
leftScreen.setAttribute("x", LEFT_SCREEN_X);
leftScreen.setAttribute("y", LEFT_SCREEN_Y);
svg.appendChild(leftScreen);

const rightScreen = svgElement("use");
rightScreen.setAttribute("href", "#screen");
rightScreen.setAttribute("x", RIGHT_SCREEN_X);
rightScreen.setAttribute("y", RIGHT_SCREEN_Y);
svg.appendChild(rightScreen);

const scores = [];
for (let i = 0; i < 2; ++i) {
  const scoreText = svgElement("text");
  if (i === 0) {
    scoreText.setAttribute("x", LEFT_SCREEN_X);
    scoreText.setAttribute("y", LEFT_SCREEN_Y + VISIBLE_HEIGHT+0.8);
  } else {
    scoreText.setAttribute("x", RIGHT_SCREEN_X);
    scoreText.setAttribute("y", RIGHT_SCREEN_Y + VISIBLE_HEIGHT+0.8);
  }

  const scoreLabel = svgElement("tspan");
  scoreLabel.classList.add("score-label");
  scoreLabel.textContent = "Score:";
  scoreText.appendChild(scoreLabel);

  const scoreDisplay = svgElement("tspan");
  scoreDisplay.classList.add("score");
  scoreDisplay.textContent = "0";
  scoreText.appendChild(scoreDisplay);

  scores.push(scoreDisplay);
  svg.appendChild(scoreText);
}

const winCounters = [];
for (let i = 0; i < 2; ++i) {
  const trophy = svgElement("text");
  trophy.classList.add("score-label");
  trophy.setAttribute("text-anchor", "middle");
  trophy.textContent = "🏆";
  const winCounter = svgElement("text");
  winCounter.classList.add("score");
  winCounter.setAttribute("text-anchor", "middle");
  winCounter.textContent = "0";
  if (i === 0) {
    trophy.setAttribute("x", LEFT_SCREEN_X - 1);
    trophy.setAttribute("y", LEFT_SCREEN_Y + 10.6);
    winCounter.setAttribute("x", LEFT_SCREEN_X - 1);
    winCounter.setAttribute("y", LEFT_SCREEN_Y + 11.5);
  } else {
    trophy.setAttribute("x", RIGHT_SCREEN_X - 1);
    trophy.setAttribute("y", RIGHT_SCREEN_Y + 10.6);
    winCounter.setAttribute("x", RIGHT_SCREEN_X - 1);
    winCounter.setAttribute("y", RIGHT_SCREEN_Y + 11.5);
  }
  winCounters.push(winCounter);
  svg.appendChild(trophy);
  svg.appendChild(winCounter);
}

function restart(event) {
  guard(event);
  waitingForStrategy = false;
  workerGameAge = 0;
  botThrottleFrames = 0;
  userMove = undefined;
  gameOvers.fill(false);
  replaying = false;
  replayIndicator.setAttribute("href", "#rec");
  seed = randomSeed();
  moves = [];
  gameAge = 0;
  game = new MultiplayerGame(seed);
  workerGame = game.clone();
  // Does essentially nothing, but documents the intention.
  for (let i = 0; i < workerAnticipation; ++i) {
    workerGame.tick();
    workerGameAge++;
  }
  screenColors[0].fill(-1);
  screenColors[1].fill(-1);
  preIgnitions[0].fill(false);
  preIgnitions[1].fill(false);
  gameOvers.fill(false);
  disableUserInput();
  enableUserInput();
  startTime = undefined;
}

const restartButton = svgElement("ellipse");
restartButton.setAttribute("fill", "#586");
restartButton.setAttribute("stroke", "#7a8");
restartButton.setAttribute("stroke-width", 0.1);
restartButton.setAttribute("rx", 1.7);
restartButton.setAttribute("ry", 0.8);
restartButton.setAttribute("cx", RIGHT_SCREEN_X+1.7);
restartButton.setAttribute("cy", RIGHT_SCREEN_Y + VISIBLE_HEIGHT + 2);
svg.appendChild(restartButton);
const restartText = svgElement("text");
restartText.classList.add("shadowed-text");
restartText.setAttribute("fill", "#cfd");
restartText.setAttribute("x", RIGHT_SCREEN_X+1.7);
restartText.setAttribute("y", RIGHT_SCREEN_Y + VISIBLE_HEIGHT + 2);
restartText.textContent = "Restart";
svg.appendChild(restartText);

restartButton.addEventListener("mousedown", guard);
restartButton.addEventListener("click", restart);
restartText.addEventListener("mousedown", guard);
restartText.addEventListener("click", restart);

function replay(event) {
  guard(event);
  game = new MultiplayerGame(seed);
  workerGame = game.clone();
  gameAge = 0;
  replaying = true;
  replayIndicator.setAttribute("href", "#play");
  replayIndex = 0;
  gameOvers.fill(false);
  startTime = undefined;
  // Make the moves available for debugging.
  window.replayMoves = moves;
}

const replayButton = svgElement("ellipse");
replayButton.setAttribute("fill", "#586");
replayButton.setAttribute("stroke", "#7a8");
replayButton.setAttribute("stroke-width", 0.1);
replayButton.setAttribute("rx", 1.7);
replayButton.setAttribute("ry", 0.8);
replayButton.setAttribute("cx", RIGHT_SCREEN_X+5.5);
replayButton.setAttribute("cy", RIGHT_SCREEN_Y + VISIBLE_HEIGHT + 2);
svg.appendChild(replayButton);
const replayText = svgElement("text");
replayText.classList.add("shadowed-text");
replayText.setAttribute("fill", "#cfd");
replayText.setAttribute("x", RIGHT_SCREEN_X+5.5);
replayText.setAttribute("y", RIGHT_SCREEN_Y + VISIBLE_HEIGHT + 2);
replayText.textContent = "Replay";
svg.appendChild(replayText);

restartButton.addEventListener("mousedown", guard);
restartButton.addEventListener("click", replay);
replayText.addEventListener("mousedown", guard);
replayText.addEventListener("click", replay);

const replayIndicator = svgElement("use");
replayIndicator.setAttribute("href", "#stop");
replayIndicator.classList.add("shadowed-text");
replayIndicator.setAttribute("x", RIGHT_SCREEN_X+7.7);
replayIndicator.setAttribute("y", RIGHT_SCREEN_Y+ VISIBLE_HEIGHT + 2);
svg.appendChild(replayIndicator);

const allClearLabels = [];
for (let i = 0; i < 2; ++i) {
  const allClearPath = svgElement("path");
  allClearPath.setAttribute("id", `all-clear-path-${i}`);
  if (i === 0) {
    allClearPath.setAttribute("d", `M ${LEFT_SCREEN_X+0.9} ${LEFT_SCREEN_Y+2} q 2.05 -0.5 4.2 0`);
  } else {
    allClearPath.setAttribute("d", `M ${RIGHT_SCREEN_X+0.9} ${RIGHT_SCREEN_Y+2} q 2.05 -0.5 4.2 0`);
  }
  allClearPath.setAttribute("fill", "none");
  svg.appendChild(allClearPath);
  const text = svgElement("text");
  const textPath = svgElement("textPath");
  textPath.setAttribute("href", `#all-clear-path-${i}`);
  text.appendChild(textPath);
  text.classList.add("all-clear");
  svg.appendChild(text);

  allClearLabels.push(textPath);
}

function guard(event) {
  event.preventDefault();
  event.stopPropagation();
}

const difficultyElements = [];

DIFFICULTIES.forEach((difficulty, i) => {
  const x = RIGHT_SCREEN_X + 7.8;
  const y = RIGHT_SCREEN_Y + 5.5 + 1.85*i;

  const button = svgElement("ellipse");
  button.classList.add("difficulty-button");
  button.setAttribute("rx", 1.4);
  button.setAttribute("ry", 0.8);
  button.setAttribute("cx", x);
  button.setAttribute("cy", y);
  svg.appendChild(button);

  const text = svgElement("text");
  text.classList.add("shadowed-text");
  text.classList.add("difficulty-text");
  text.setAttribute("x", x);
  text.setAttribute("y", y);
  text.textContent = difficulty.label;
  svg.appendChild(text);

  if (difficulty.label === "Easy") {
    button.classList.add("active");
    text.classList.add("active");
  }

  const myBotName = difficulty.botName;
  const myThrottleFrames = difficulty.throttleFrames;
  const myKickDown = difficulty.kickDown;

  function click(event) {
    guard(event);
    let activate = false;
    if (button.classList.contains("active")) {
      botName = "none";
    } else {
      activate = true;
      botName = myBotName;
      botInitialThrottleFrames = myThrottleFrames;
      botKickDown = myKickDown;
    }
    difficultyElements.forEach(element => element.classList.remove("active"));
    if (activate) {
      button.classList.add("active");
      text.classList.add("active");
    }
  }
  button.addEventListener("click", click);
  button.addEventListener("mousedown", guard);
  text.addEventListener("click", click);
  text.addEventListener("mousedown", guard);

  difficultyElements.push(button);
  difficultyElements.push(text);
});

for (let i = 0; i < 2; ++i) {
  const branding = svgElement("g");
  const titleUnderLine = svgElement("rect");
  titleUnderLine.setAttribute("x", LEFT_SCREEN_X);
  titleUnderLine.setAttribute("y", LEFT_SCREEN_Y + VISIBLE_HEIGHT + 2.2);
  titleUnderLine.setAttribute("width", 3.8);
  titleUnderLine.setAttribute("height", 0.05);
  branding.appendChild(titleUnderLine);
  const titleText = svgElement("text");
  titleText.classList.add("title");
  titleText.setAttribute("x", LEFT_SCREEN_X);
  titleText.setAttribute("y", LEFT_SCREEN_Y + VISIBLE_HEIGHT + 2.1);
  titleText.textContent = "Artemisia";
  branding.appendChild(titleText);
  const subtitleText = svgElement("text");
  subtitleText.classList.add("subtitle");
  subtitleText.setAttribute("x", LEFT_SCREEN_X);
  subtitleText.setAttribute("y", LEFT_SCREEN_Y + VISIBLE_HEIGHT + 2.62);
  subtitleText.textContent = "a.k.a. Pujo Puyo";
  branding.appendChild(subtitleText);

  const logo = svgElement("use");
  logo.setAttribute("x", LEFT_SCREEN_X+4.5);
  logo.setAttribute("y", LEFT_SCREEN_Y + VISIBLE_HEIGHT + 1.2);
  logo.setAttribute("transform-origin", `${LEFT_SCREEN_X} ${LEFT_SCREEN_Y + VISIBLE_HEIGHT + 1.2}`);
  logo.setAttribute("transform", "scale(0.9)");
  branding.appendChild(logo);

  if (i === 0) {
    logo.setAttribute("href", "#plain-logo");
    branding.setAttribute("filter", "url(#blur)");
    branding.setAttribute("fill", "white");
    branding.setAttribute("opacity", 0.5);
  } else {
    logo.setAttribute("href", "#logo");
    branding.setAttribute("fill", "#887");
  }
  svg.appendChild(branding);
}


const leftContent = svgElement("g");
leftContent.setAttribute("transform", `translate(${LEFT_SCREEN_X},${LEFT_SCREEN_Y})`);
svg.appendChild(leftContent);

const rightContent = svgElement("g");
rightContent.setAttribute("transform", `translate(${RIGHT_SCREEN_X},${RIGHT_SCREEN_Y})`);
svg.appendChild(rightContent);

const contents = [leftContent, rightContent];

const chainBoxes = [];
const chainTexts = [];
const chainAnimations = [];
const chains = [];
for (let i = 0; i < NUM_CARD_INDICES; ++i) {
  const chain = svgElement("g");
  chain.setAttribute("opacity", 0);
  const chainBox = svgElement("rect");
  chainBox.setAttribute("rx", 0.2);
  chainBox.setAttribute("ry", 0.2);
  chainBox.setAttribute("height", 1);
  chainBox.setAttribute("fill", CHAIN_FILL);
  chainBox.setAttribute("stroke", CHAIN_BORDER);
  chainBox.setAttribute("stroke-width", CHAIN_BORDER_WIDTH);
  const chainText = svgElement("text");
  chainText.classList.add("chain");
  chainText.textContent = "0-Chain";
  chainText.setAttribute("x", 0.2);
  chainText.setAttribute("y", 0.75);
  chain.appendChild(chainBox);
  chain.appendChild(chainText);

  const animation = svgElement("animate");
  animation.setAttribute("attributeName", "opacity");
  animation.setAttribute("values", "0");
  animation.setAttribute("begin", "0s");
  animation.setAttribute("dur", "1.3s");
  animation.setAttribute("repeatCount", "1");
  animation.setAttribute("fill", "freeze");
  chain.appendChild(animation);

  chainBoxes.push(chainBox);
  chainTexts.push(chainText);
  chainAnimations.push(animation);
  chains.push(chain);

  svg.appendChild(chain);
}

const gameOverBackgrounds = [];
const gameLabels = [];
const overLabels = [];
const overPaths = [];
for (let i = 0; i < 2; ++i) {
  const background = svgElement("ellipse");
  if (i === 0) {
    background.setAttribute("cx", LEFT_SCREEN_X + 3);
    background.setAttribute("cy", LEFT_SCREEN_Y + 4.2);
  } else {
    background.setAttribute("cx", RIGHT_SCREEN_X + 3);
    background.setAttribute("cy", RIGHT_SCREEN_Y + 4.2);
  }
  background.setAttribute("rx", "2.6");
  background.setAttribute("ry", "1.7");
  background.setAttribute("fill", "none");
  background.setAttribute("stroke", "none");
  background.setAttribute("stroke-width", "0.1");
  gameOverBackgrounds.push(background);
  svg.appendChild(background);

  const gamePath = svgElement("path");
  gamePath.setAttribute("id", `game-path-${i}`);
  const overPath = svgElement("path");
  overPath.setAttribute("id", `over-path-${i}`);
  if (i === 0) {
    gamePath.setAttribute("d", `M ${LEFT_SCREEN_X+1.2} ${LEFT_SCREEN_Y+4} q 1.9 0.4 3.8 0`);
    overPath.setAttribute("d", `M ${LEFT_SCREEN_X+1.4} ${LEFT_SCREEN_Y+5.2} q 1.65 0.2 3.3 0`);
  } else {
    gamePath.setAttribute("d", `M ${RIGHT_SCREEN_X+1.2} ${RIGHT_SCREEN_Y+4} q 1.9 0.4 3.8 0`);
    overPath.setAttribute("d", `M ${RIGHT_SCREEN_X+1.4} ${RIGHT_SCREEN_Y+5.2} q 1.65 0.2 3.3 0`);
  }
  gamePath.setAttribute("fill", "none");
  overPath.setAttribute("fill", "none");
  overPath.setAttribute("stroke", "none");
  overPath.setAttribute("stroke-width", "0.2");
  overPaths.push(overPath);
  svg.appendChild(gamePath);
  svg.appendChild(overPath);
  {
    const text = svgElement("text");
    const textPath = svgElement("textPath");
    textPath.setAttribute("href", `#game-path-${i}`);
    textPath.setAttribute("textLength", "20%");
    text.appendChild(textPath);
    text.classList.add("game-over");
    svg.appendChild(text);
    gameLabels.push(textPath);
  }
  const text = svgElement("text");
  const textPath = svgElement("textPath");
  textPath.setAttribute("href", `#over-path-${i}`);
  textPath.setAttribute("textLength", "17%");
  text.appendChild(textPath);
  text.classList.add("game-over");
  svg.appendChild(text);
  overLabels.push(textPath);
}

function panelSymbol(color, jiggle = false) {
  if (color === RED) {
    return jiggle ? "#jiggling-heart" : "#heart";
  } else if (color === GREEN) {
    return jiggle ? "#jiggling-circle" : "#small-circle";
  } else if (color === YELLOW) {
    return jiggle ? "#jiggling-star" : "#small-star";
  } else if (color === BLUE) {
    return jiggle ? "#jiggling-moon" : "#small-moon";
  } else if (color === PURPLE) {
    return jiggle ? "#jiggling-diamond" : "#small-diamond";
  }
}

function panelAt(x, y, color, connectivity = 0, jiggle = false, ignited = false, preIgnited = false) {
  const element = svgElement("use");
  if (color === GARBAGE) {
    element.setAttribute("href", jiggle ? "#jiggling-garbage": "#garbage");
  } else {
    element.setAttribute("href", `#panel${connectivity}`);
  }
  element.setAttribute("x", x + 0.5);
  element.setAttribute("y", y + 0.5);
  element.setAttribute("fill", ignited ? IGNITION_FILL : FILLS[color]);
  element.setAttribute("stroke", STROKES[color]);
  element.setAttribute("stroke-width", STROKE_WIDTH);
  if (color === GARBAGE) {
    return element;
  }
  const group = svgElement("g");
  group.appendChild(element);
  if (preIgnited) {
    const preIgnition = svgElement("use");
    preIgnition.setAttribute("href", "#pre-ignition");
    preIgnition.setAttribute("x", x);
    preIgnition.setAttribute("y", y);
    group.appendChild(preIgnition);
  }
  const glyph = svgElement("use");
  glyph.setAttribute("x", x + 0.5);
  glyph.setAttribute("y", y + 0.5);
  glyph.setAttribute("fill", STROKES[color]);
  glyph.setAttribute("href", panelSymbol(color, jiggle));
  group.appendChild(glyph);
  return group;
}

function renderGame() {
  for (let cardIndex = 0; cardIndex < NUM_CARD_INDICES; ++cardIndex) {
    chainBoxes[cardIndex].setAttribute("width", chainTexts[cardIndex].getBBox().width + 0.4);
  }

  const gameState = game.state;

  for (let i = 0; i < 2; ++i) {
    const currentTime = svg.getCurrentTime();

    const newGhostChildren = [];
    for (let x = 0; x < WIDTH; ++x) {
      const arrayIndex = x + GHOST_Y * WIDTH;
      const color = gameState[i].screen.grid[arrayIndex];
      if (color >= 0) {
        const ghostPanel = svgElement("use");
        if (color === GARBAGE) {
          ghostPanel.setAttribute("href", "#garbage");
        } else {
          ghostPanel.setAttribute("href", "#panel0");
        }
        ghostPanel.setAttribute("x", x + 0.5);
        ghostPanel.setAttribute("y", -0.5);
        ghostPanel.setAttribute("fill", "none");
        ghostPanel.setAttribute("stroke", STROKES[color]);
        ghostPanel.setAttribute("stroke-width", STROKE_WIDTH * 0.5);
        ghostPanel.setAttribute("stroke-dasharray", "0.1 0.108");
        ghostPanel.setAttribute("stroke-linecap", "round");
        ghostPanel.setAttribute("stroke-linejoin", "round");
        ghostPanel.setAttribute("mask", "url(#fade-mask)");
        newGhostChildren.push(ghostPanel);
      }
    }
    ghostContents[i].replaceChildren(...newGhostChildren);

    allClearLabels[i].textContent = gameState[i].allClearBonus ? "All Clear" : "";

    if (gameOvers[i]) {
      gameLabels[i].textContent = "Game";
      overLabels[i].textContent = "Over";
      overPaths[i].setAttribute("stroke", "red");
      gameOverBackgrounds[i].setAttribute("fill", "rgba(0, 0, 0, 0.6)");
      gameOverBackgrounds[i].setAttribute("stroke", "rgba(0, 0, 0, 0.7)");
    } else {
      gameLabels[i].textContent = "";
      overLabels[i].textContent = "";
      overPaths[i].setAttribute("stroke", "none");
      gameOverBackgrounds[i].setAttribute("fill", "none");
      gameOverBackgrounds[i].setAttribute("stroke", "none");
    }

    const newChildren = [];

    const {pending, late} = combinedGarbageDisplay(gameState[i].pendingGarbage, gameState[i].lateGarbage);
    let x = 0;
    pending.forEach((symbol) => {
      if (symbol === "rock") {
        symbol = "spade";
      } else if (symbol === "crown") {
        symbol = "diamond";
      }
      const glyph = svgElement("use");
      glyph.setAttribute("href", "#" + symbol);
      glyph.setAttribute("fill", FILLS[GARBAGE]);
      glyph.setAttribute("stroke", STROKES[GARBAGE]);
      glyph.setAttribute("stroke-width", STROKE_WIDTH);
      glyph.setAttribute("x", x + 0.5);
      glyph.setAttribute("y", -1);
      newChildren.push(glyph);
      x += 1
    });
    late.forEach((symbol) => {
      if (symbol === "rock") {
        symbol = "spade";
      } else if (symbol === "crown") {
        symbol = "diamond";
      }
      const glyph = svgElement("use");
      glyph.setAttribute("href", "#" + symbol);
      glyph.setAttribute("fill", FILLS[GARBAGE]);
      glyph.setAttribute("opacity", 0.5);
      glyph.setAttribute("stroke", STROKES[GARBAGE]);
      glyph.setAttribute("stroke-width", STROKE_WIDTH);
      glyph.setAttribute("x", x + 0.5);
      glyph.setAttribute("y", -1);
      newChildren.push(glyph);
      x += 1
    });

    const previewBag = gameState[i].preview;
    newChildren.push(panelAt(WIDTH + 0.5, 1, previewBag[0]));
    newChildren.push(panelAt(WIDTH + 0.5, 0, previewBag[1]));
    newChildren.push(panelAt(WIDTH + 1, 3.2, previewBag[2]));
    newChildren.push(panelAt(WIDTH + 1, 2.2, previewBag[3]));

    let numIgnitions = 0;
    let ignitionX = 0;
    let ignitionY = 0;

    for (let y = 0; y < VISIBLE_HEIGHT; ++y) {
      for (let x = 0; x < WIDTH; ++x) {
        const arrayIndex = x + (y + GHOST_Y + 1) * WIDTH;
        const color = gameState[i].screen.grid[arrayIndex];
        screenColors[i][x + y * WIDTH] = color;
        if (color >= 0) {
          const screen = gameState[i].screen;
          if (screen.ignited[arrayIndex]) {
            numIgnitions++;
            ignitionX += x;
            ignitionY += y;
          }

          if (screen.sparking[arrayIndex]) {
            // Garbage sparks are invisible even if they still support the panels above.
            if (color !== GARBAGE) {
              const sparks = svgElement("use");
              sparks.setAttribute("href", "#sparks");
              sparks.setAttribute("x", x + 0.5);
              sparks.setAttribute("y", y + 0.5);
              sparks.setAttribute("fill", STROKES[color]);
              newChildren.push(sparks);
            }
          } else {
            const panel = panelAt(x, y, color, screen.connectivity[arrayIndex], screen.jiggling[arrayIndex], screen.ignited[arrayIndex], preIgnitions[i][arrayIndex]);
            if (screen.falling[arrayIndex]) {
              const animation = svgElement("animateTransform");
              animation.setAttribute("attributeName", "transform");
              animation.setAttribute("attributeType", "XML");
              animation.setAttribute("type", "translate");
              animation.setAttribute("from", "0 0");
              animation.setAttribute("to", "0 1");
              animation.setAttribute("begin", `${currentTime}s`);
              animation.setAttribute("dur", `${1/FRAME_RATE}s`);
              animation.setAttribute("repeatCount", 1);
              animation.setAttribute("fill", "freeze");

              panel.appendChild(animation);
            }

            newChildren.push(panel);
          }
        }
      }
    }

    if (numIgnitions) {
      ignitionCenters[i][0] = ignitionX / numIgnitions;
      ignitionCenters[i][1] = ignitionY / numIgnitions;
    }

    contents[i].replaceChildren(...newChildren);

    scores[i].textContent = gameState[i].score;
  }
}

function draw(timeStamp) {
  if (startTime === undefined) {
    startTime = timeStamp;
  }
  const elapsed = timeStamp - startTime;
  const intendedAge = Math.min(FRAME_RATE * elapsed / 1000, gameAge + FRAME_RATE);

  const needsRedraw = (gameAge < intendedAge);

  while (gameAge < intendedAge) {
    const tickResults = game.tick();

    for (let i = 0; i < 2; ++i) {
      if (tickResults[i].lockedOut) {
        if (!gameOvers[i] && !gameOvers[1-i] && !replaying) {
          wins[1-i]++;
          winCounters[1-i].textContent = wins[1-i];
        }
        gameOvers[i] = true;
      }
      if (tickResults[i].didClear) {
        const cardIndex = nextChainCards[i];

        const x = i === 0 ? LEFT_SCREEN_X : RIGHT_SCREEN_X;
        const y = i === 0 ? LEFT_SCREEN_Y : RIGHT_SCREEN_Y;
        chains[cardIndex].setAttribute("transform", `translate(${x + ignitionCenters[i][0]}, ${y + ignitionCenters[i][1] - 0.5})`);
        chains[cardIndex].setAttribute("opacity", 0.1);

        chainAnimations[cardIndex].setAttribute("begin", `${svg.getCurrentTime()}s`);
        chainAnimations[cardIndex].setAttribute("values", "0.1;1;0.95;0.9;0.8;0.7;0");

        const chainNumber = tickResults[i].chainNumber;
        if (chainNumber > 0) {
          chainTexts[cardIndex].textContent = `${chainNumber}-Chain`;
          playSoundFX(i, chainNumber);
        }
        nextChainCards[i] = juggleCards(cardIndex);
      }
    }

    if (replaying) {
      disableUserInput();

      while(replayIndex < moves.length && moves[replayIndex][0] <= gameAge) {
        const move = moves[replayIndex++].slice(1);
        game.play(...move);
      }
      if (replayIndex >= moves.length) {
        replayIndicator.setAttribute("href", "#pause");
      }
    } else {

      // User input for the left screen.
      if (tickResults[0].busy) {
        disableUserInput();
      } else {
        enableUserInput();
      }

      if (!tickResults[0].busy && userMove !== undefined) {
        game.play(0, ...userMove);
        userMove.unshift(0);
        userMove.unshift(gameAge);
        moves.push(userMove);
        userMove = undefined;

        workerGame = game.clone();
        workerGameAge = gameAge;
        while(workerGameAge < gameAge + workerAnticipation) {
          workerGame.tick();
          workerGameAge++;
        }
      }

      // Worker thread for the CPU opponent.
      if (!tickResults[1].busy && workerStrategy !== undefined) {
        const {move, score} = workerStrategy;
        if (move !== PASS) {
          const {x1, y1, orientation} = MOVES[move];
          if (game.toSimpleGame(1).availableMoves.length) {
            game.play(1, x1, y1, orientation, botKickDown);
            moves.push([gameAge, 1, x1, y1, orientation, botKickDown]);
            workerGame = game.clone();
            workerGameAge = gameAge;
            while(workerGameAge < gameAge + workerAnticipation) {
              workerGame.tick();
              workerGameAge++;
            }
          }
        }
        workerStrategy = undefined;
      }

      // Anticipate moves.
      const anticipation = workerGame.tick();
      if (!anticipation[1].busy && !waitingForStrategy && botThrottleFrames <= 0) {
        if (botName !== "none") {
          waitingForStrategy = true;
          const message = {
            name: botName,
            game: workerGame.toSimpleGame(1),
            anticipation: workerAnticipation,
            throttleFrames: botInitialThrottleFrames,
            kickDown: botKickDown,
          }
          // Make sure that the bot doesn't hallucinate.
          message.game.bag = game.games[1].visibleBag;
          strategyWorker.postMessage(message);
        }
      }
    }

    gameAge++;
    botThrottleFrames--;
  }
  if (needsRedraw) {
    renderGame();
  }

  frameId = window.requestAnimationFrame(draw);
}

// Pre-render once.
renderGame();

// Worker thread for the CPU opponent.
strategyWorker.onmessage = (e) => {
  workerStrategy = e.data.strategy;
  workerAnticipation = Math.min(e.data.thinkingFrames, MAX_WORKER_ANTICIPATION);
  waitingForStrategy = false;
  botThrottleFrames = botInitialThrottleFrames;
};

// User interface
// Please note that orbit distances less than 0.5 would need updates to the second panel during cursor movement.
const MIN_ORBIT_DISTANCE = 0.5;
const MAX_ORBIT_DISTANCE = 7;
let mainPanelLocked = false;
let mainGridX = 2;
let mainGridY = 0;
let secondDeltaX = 0;
let secondDeltaY = -1;

const mainPanel = svgElement("use");
mainPanel.setAttribute("href", "#panel0");
mainPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
mainPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
mainPanel.setAttribute("fill", "none");
mainPanel.setAttribute("stroke", STROKES[game.games[0].bag[0]]);
mainPanel.setAttribute("stroke-width", STROKE_WIDTH);
svg.appendChild(mainPanel);

const mainGlyph = svgElement("use");
mainGlyph.setAttribute("fill", "none");
mainGlyph.setAttribute("href", panelSymbol(game.games[0].bag[0]));
svg.appendChild(mainGlyph);

// Extra indicator when cursor overlaps with a similar color
const mainPanelHelper = svgElement("use");
mainPanelHelper.setAttribute("href", "#panel0");
mainPanelHelper.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
mainPanelHelper.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
mainPanelHelper.setAttribute("fill", "none");
mainPanelHelper.setAttribute("stroke", "none");
mainPanelHelper.setAttribute("stroke-width", STROKE_WIDTH * 0.4);
svg.appendChild(mainPanelHelper);

const secondPanel = svgElement("use");
secondPanel.setAttribute("href", "#panel0");
secondPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + secondDeltaX + 0.5);
secondPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + secondDeltaY + 0.5);
secondPanel.setAttribute("fill", "none");
secondPanel.setAttribute("stroke", STROKES[game.games[0].bag[1]]);
secondPanel.setAttribute("stroke-width", STROKE_WIDTH * 0.5);
svg.appendChild(secondPanel);

const secondGlyph = svgElement("use");
secondGlyph.setAttribute("fill", "none");
secondGlyph.setAttribute("href", panelSymbol(game.games[0].bag[1]));
svg.appendChild(secondGlyph);

// Small landing indicators
const mainDroplet = svgElement("circle");
mainDroplet.setAttribute("r", 0.1);
mainDroplet.setAttribute("cx", LEFT_SCREEN_X + mainGridX + 0.5);
mainDroplet.setAttribute("cy", LEFT_SCREEN_Y + VISIBLE_HEIGHT - 1 + 0.5);
mainDroplet.setAttribute("fill", STROKES[game.games[0].bag[0]]);
mainDroplet.setAttribute("stroke", "white");
mainDroplet.setAttribute("stroke-width", "0.03");
mainDroplet.setAttribute("opacity", 0.7);
svg.appendChild(mainDroplet);

const secondDroplet = svgElement("circle");
secondDroplet.setAttribute("r", 0.1);
secondDroplet.setAttribute("cx", LEFT_SCREEN_X + mainGridX + secondDeltaX + 0.5);
secondDroplet.setAttribute("cy", LEFT_SCREEN_Y + VISIBLE_HEIGHT - 1 + secondDeltaY + 0.5);
secondDroplet.setAttribute("fill", STROKES[game.games[0].bag[1]]);
secondDroplet.setAttribute("stroke", "white");
secondDroplet.setAttribute("stroke-width", "0.03");
secondDroplet.setAttribute("opacity", 0.7);
svg.appendChild(secondDroplet);

function disableUserInput() {
  if (!inputEnabled) {
    return;
  }
  inputEnabled = false;

  mainPanel.setAttribute("fill", "none");
  mainPanel.setAttribute("stroke", "none");
  mainGlyph.setAttribute("fill", "none");
  mainPanelHelper.setAttribute("fill", "none");
  mainPanelHelper.setAttribute("stroke", "none");
  mainDroplet.setAttribute("fill", "none");
  mainDroplet.setAttribute("stroke", "none");
  secondPanel.setAttribute("stroke", "none");
  secondGlyph.setAttribute("fill", "none");
  secondDroplet.setAttribute("fill", "none");
  secondDroplet.setAttribute("stroke", "none");

  preIgnitions[0].fill(false);
}

function helpMainPanel() {
  if (screenColors[0][mainGridX + mainGridY * WIDTH] === game.games[0].hand[0]) {
    mainPanelHelper.setAttribute("fill", "rgba(255, 255, 255, 0.1)");
    mainPanelHelper.setAttribute("stroke", "white");
  } else {
    mainPanelHelper.setAttribute("fill", "none");
    mainPanelHelper.setAttribute("stroke", "none");
  }
}

function enableUserInput() {
  if (inputEnabled) {
    return;
  }
  inputEnabled = true;
  mainPanel.setAttribute("stroke", STROKES[game.games[0].hand[0]]);
  secondPanel.setAttribute("stroke", STROKES[game.games[0].hand[1]]);
  mainDroplet.setAttribute("fill", STROKES[game.games[0].hand[0]]);
  mainDroplet.setAttribute("stroke", "white");
  secondDroplet.setAttribute("fill", STROKES[game.games[0].hand[1]]);
  secondDroplet.setAttribute("stroke", "white");
  moveCursor(lastCursorX, lastCursorY);
}

function snapToGrid(x, y) {
  const gridX = Math.max(0, Math.min(WIDTH - 1, Math.floor(x - LEFT_SCREEN_X)));
  const gridY = Math.max(-1, Math.min(VISIBLE_HEIGHT - 1, Math.floor(y - LEFT_SCREEN_Y)));
  return {gridX, gridY};
}

function updatePanelPositions() {
  mainPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
  mainPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
  mainPanelHelper.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
  mainPanelHelper.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
  secondPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + secondDeltaX + 0.5);
  secondPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + secondDeltaY + 0.5);
  helpMainPanel();

  updateDropletPositions();
}

function updateDropletPositions() {
  if (!inputEnabled) {
    return;
  }
  let mainY = game.games[0].screen.dropPuyo(mainGridX, mainGridY + GHOST_Y + 1) - GHOST_Y - 1;
  const {hintDeltaX, hintDeltaY} = calculateHints();
  const hintX = mainGridX + hintDeltaX;
  let secondY = game.games[0].screen.dropPuyo(hintX, mainGridY + hintDeltaY + GHOST_Y + 1) - GHOST_Y - 1;
  if (mainY === secondY && mainGridX === hintX) {
    if (secondDeltaY > 0) {
      mainY--;
    } else {
      secondY--;
    }
  }
  mainDroplet.setAttribute("cx", LEFT_SCREEN_X + mainGridX + 0.5);
  mainDroplet.setAttribute("cy", LEFT_SCREEN_Y + mainY + 0.5);
  secondDroplet.setAttribute("cx", LEFT_SCREEN_X + hintX + 0.5);
  secondDroplet.setAttribute("cy", LEFT_SCREEN_Y + secondY + 0.5);

  if (mainPanelLocked) {
    if (hintX === mainGridX && secondY === mainGridY) {
      mainPanel.setAttribute("fill", "none");
    } else {
      mainPanel.setAttribute("fill", FILLS[game.games[0].hand[0]]);
    }
  }

  preIgnitions[0] = game.games[0].screen.preIgnite(mainGridX, mainY + GHOST_Y + 1, game.games[0].hand[0], hintX, secondY + GHOST_Y + 1, game.games[0].hand[1]);
}

function updateGlyphPositions() {
  mainGlyph.setAttribute("x", LEFT_SCREEN_X + mainGridX + 0.5);
  mainGlyph.setAttribute("y", LEFT_SCREEN_Y + mainGridY + 0.5);
  secondGlyph.setAttribute("x", LEFT_SCREEN_X + mainGridX + secondDeltaX + 0.5);
  secondGlyph.setAttribute("y", LEFT_SCREEN_Y + mainGridY + secondDeltaY + 0.5);
}

function kickCursor() {
  while (mainGridX < 0) {
    mainGridX++;
  }
  while (mainGridX + secondDeltaX < 0) {
    mainGridX++;
  }
  while (mainGridX + secondDeltaX >= WIDTH) {
    mainGridX--;
  }
  while (mainGridX >= WIDTH) {
    mainGridX--;
  }
  while (mainGridY < -2) {
    mainGridY++;
  }
  while (mainGridY >= VISIBLE_HEIGHT) {
    mainGridY--;
  }
  while (mainGridY + secondDeltaY >= VISIBLE_HEIGHT) {
    mainGridY--;
  }
}

let lastCursorX = undefined;
let lastCursorY = undefined;
function moveCursor(x, y) {
  if (x !== undefined && y !== undefined) {
    lastCursorX = x;
    lastCursorY = y;
    const {gridX, gridY} = snapToGrid(x, y);
    mainGridX = gridX;
    mainGridY = gridY;
  }
  kickCursor();
  if (inputEnabled) {
    updatePanelPositions();
  }
}

function lockMainPanel(x, y) {
  if (mainPanelLocked || game.games[0].busy || !inputEnabled) {
    return;
  }
  moveCursor(x, y);

  // Kick the main panel up for a less cluttered UX.
  mainGridY = game.games[0].screen.kickPuyo(mainGridX, mainGridY + GHOST_Y + 1) - GHOST_Y - 1;

  updatePanelPositions();
  updateGlyphPositions();

  mainPanelLocked = true;

  mainPanel.setAttribute("fill", FILLS[game.games[0].hand[0]]);

  mainGlyph.setAttribute("fill", STROKES[game.games[0].hand[0]]);
  mainGlyph.setAttribute("href", panelSymbol(game.games[0].hand[0]));

  secondGlyph.setAttribute("fill", STROKES[game.games[0].hand[1]]);
  secondGlyph.setAttribute("href", panelSymbol(game.games[0].hand[1]));
}

function unlockMainPanel(x, y) {
  mainPanelLocked = false;
  secondDeltaX = 0;
  secondDeltaY = -1;
  moveCursor(x, y);

  mainPanel.setAttribute("fill", "none");
  mainGlyph.setAttribute("fill", "none");
  secondGlyph.setAttribute("fill", "none");
}

function calculateHints() {
  let hintDeltaX = secondDeltaX;
  let hintDeltaY = secondDeltaY;

  if (Math.abs(secondDeltaY) === 1) {
    hintDeltaX = 0;
  } else {
    hintDeltaY = 0;
  }
  return {hintDeltaX, hintDeltaY};
}

function orbitSecondPanel(x, y) {
  const viewBoxX = LEFT_SCREEN_X + mainGridX + 0.5;
  const viewBoxY = LEFT_SCREEN_Y + mainGridY + 0.5;

  const dx = x - viewBoxX;
  const dy = y - viewBoxY;
  const distance = Math.hypot(dx, dy);

  if (distance > MAX_ORBIT_DISTANCE) {
    unlockMainPanel(x, y);
  } else if (distance > MIN_ORBIT_DISTANCE) {
    if (Math.abs(dx) > Math.abs(dy)) {
      secondDeltaX = Math.sign(dx);
      secondDeltaY = dy / Math.abs(dx);
    } else {
      secondDeltaX = dx / Math.abs(dy);
      secondDeltaY = Math.sign(dy);
    }

    // Main panel locked, cannot kick.
    if ((mainGridX + secondDeltaX < 0) || (mainGridX + secondDeltaX >= WIDTH)) {
      secondDeltaY = Math.sign(secondDeltaY) || 1;
    }
    // Vertical pseudo-kicks are fine. They happens against screen content anyway.

    const {hintDeltaX, hintDeltaY} = calculateHints();

    secondPanel.setAttribute("x", LEFT_SCREEN_X + mainGridX + secondDeltaX + 0.5);
    secondPanel.setAttribute("y", LEFT_SCREEN_Y + mainGridY + secondDeltaY + 0.5);

    secondGlyph.setAttribute("x", LEFT_SCREEN_X + mainGridX + hintDeltaX + 0.5);
    secondGlyph.setAttribute("y", LEFT_SCREEN_Y + mainGridY + hintDeltaY + 0.5);

    updateDropletPositions();
  }
}

function getOrientation() {
  if (secondDeltaY === -1) {
    return 0;
  }
  if (secondDeltaY === 1) {
    return 2;
  }
  if (secondDeltaX === -1) {
    return 1;
  }
  if (secondDeltaX === 1) {
    return 3;
  }
  return 0;
}

function setOrientation(orientation) {
  orientation &= 3;
  if (orientation === 0) {
    secondDeltaX = 0;
    secondDeltaY = -1;
  } else if (orientation === 1) {
    secondDeltaX = -1;
    secondDeltaY = 0;
  } else if (orientation === 2) {
    secondDeltaX = 0;
    secondDeltaY = 1;
  } else if (orientation === 3) {
    secondDeltaX = 1;
    secondDeltaY = 0;
  }
  // Kick or unkick as necessary.
  moveCursor(lastCursorX, lastCursorY);
}

function commitMove(x, y) {
  if (game.games[0].busy || !mainPanelLocked) {
    return;
  }
  if (x !== undefined && y !== undefined) {
    orbitSecondPanel(x, y);
  }
  // Commit hint
  const {hintDeltaX, hintDeltaY} = calculateHints();
  secondDeltaX = hintDeltaX;
  secondDeltaY = hintDeltaY;

  userMove = [mainGridX, mainGridY + GHOST_Y + 1, getOrientation(), false];

  mainPanelLocked = false;
  secondDeltaX = 0;
  secondDeltaY = -1;

  kickCursor();
  updatePanelPositions();
  disableUserInput();
}

// Sound FX
const AUDIO_LAG = 0.01;  // Make audio laggy but less clicky.
const MIRACLE_HEXAD_RATIOS = [1.12373, 1.24848, 1.42557, 1.60195, 1.75156];
const MIRACLE_CHORD = [830];
for (let i = 0; i < 5; ++i) {
  MIRACLE_CHORD.push(MIRACLE_HEXAD_RATIOS[i] * 830);
}
for (let i = 3; i >= 0; --i) {
  MIRACLE_CHORD.push(MIRACLE_HEXAD_RATIOS[i] * 1660);
}

const ARPEGGIOS = [
  edArpeggio([0, 1, 2, 3], 7, 2, 430),  // 7-edo cluster, slightly lower.
  edArpeggio([0, 2, 4, 6]),  // Whole-tone cluster.
  edArpeggio([0, 1, 2, 3], 5, 2, 453),  // 5-edo cluster, slightly higher.
  edArpeggio([1, 4, 7, 10]),  // Fully diminished chord.
  [494, 494 * 6/5, 494 * 3/2, 494 * 9 / 5],  // Just minor seventh chord.
  [523, 523 * 5/4, 523 * 6/4, 523 * 7/4],  // Harmonic seventh chord.
  edArpeggio([4, 8, 12, 16]),  // Augmented chord.
  [587, 587 * 4/3, 587 * 16/9, 587 * 64/27],  // Stack of just fourths.
  [622, 622 * 11/8, 622 * 121/60, 622 * 1331/512],  // Stack of just superfourths.
  [659, 659 * 3/2, 659 * 9/4, 659 * 27/8],  // Stack of just fifths.
  [6660 / 9, 6660 / 8, 6660 / 7, 6660 / 6, 6660 / 5, 6660 / 4, 6660 / 3],  // Subharmonics 9-3.
  edArpeggio([0, 1, 3, 5, 7, 11, 13], 9, 2, 698),  // Prime steps of 9-edo.
  [8624 / 11, 8624 / 10, 8624 / 9, 8624 / 8, 8624 / 7, 8624 / 6, 8624 / 5, 8624 / 4],  // Subharmonics 11-4.
  MIRACLE_CHORD,  // Essentially tempered Miracle hexad.
  [880, 880 * 13/10, 880 * 15/10, 880 * 16/10, 880 * 19/10, 880 * 18/10, 880 * 25/10, 880 * 24/10],  // Supermajor chord with otonal extensions.
  edArpeggio([0, 7, 13, 40, 36, 34, 20, 26, 30], 23, 2, 932),  // Anti-minor chord with random extensions.
  [2303, 1523, 3754, 2910, 3312, 2563, 3259, 1061, 2888],  // Completely random chord.
  [1209, 1336, 1477, 1633, 697, 770, 852, 941],  // DTMF.
  edArpeggio([0, 2, 3, 5, 2, 2, -2, 0, 0, -12, 12, 12]),  // The Lick.
];

let context;
const oscillators = [];
const envelopes = [];

function initialize() {
  if (frameId === undefined) {
    frameId = window.requestAnimationFrame(draw);
    replayIndicator.setAttribute("href", "#rec");
  }

  if (context === undefined) {
    context = new AudioContext({latencyHint: "interactive"});

    const delay = new PingPongDelay(context, 1);
    delay.delayTime = 0.1;
    delay.feedback = 0.4;
    delay.separation = 0.3;
    delay.connect(context.destination);

    for (let i = 0; i < 2; ++i) {
      // Give each player a voice through slight variation of the oscillators.
      let oscillator;
      if (i === 0) {
        oscillator = createSoftSquare(context);
      } else {
        oscillator = createSoftSquare(context, 0.085, 0.42, 0.06);
      }
      const envelope = context.createGain();

      oscillator.connect(envelope).connect(delay.destination)

      envelope.gain.setValueAtTime(0, context.currentTime);
      oscillator.start(context.currentTime);
      oscillators.push(oscillator);
      envelopes.push(envelope);
    }
  }
}

function playSoundFX(player, chainNumber) {
  if (context === undefined) {
    return;
  }
  // Try to resolve some glitches
  oscillators[player].frequency.cancelScheduledValues(context.currentTime);
  oscillators[player].frequency.setValueAtTime(ARPEGGIOS[chainNumber][0], context.currentTime);
  envelopes[player].gain.cancelScheduledValues(context.currentTime);

  const now = context.currentTime + AUDIO_LAG;
  envelopes[player].gain.setValueAtTime(0.45, now);
  envelopes[player].gain.exponentialRampToValueAtTime(1e-5, now + 3);
  arpegiate(oscillators[player], ARPEGGIOS[chainNumber - 1], now, now + 3);
}

const pt = svg.createSVGPoint();
function viewBoxCoords(event) {
  pt.x = event.x;
  pt.y = event.y;
  return  pt.matrixTransform(svg.getScreenCTM().inverse());
  return {x, y};
}

document.addEventListener("mousemove", (e) => {
  const {x, y} = viewBoxCoords(e);
  if (mainPanelLocked) {
    orbitSecondPanel(x, y);
  } else {
    moveCursor(x, y);
  }
});

svg.addEventListener("mousedown", (e) => {
  initialize();
  if (e.button !== 0) {
    return;
  }
  const {x, y} = viewBoxCoords(e);
  lockMainPanel(x, y);
});

svg.addEventListener("mouseup", (e) => {
  if (e.button !== 0) {
    return;
  }
  const {x, y} = viewBoxCoords(e);
  commitMove(x, y);
});

const ARROW_KEYS = ["ArrowUp", "ArrowLeft", "ArrowDown", "ArrowRight"];
const WASD_KEYS = ["KeyW", "KeyA", "KeyS", "KeyD"];

document.addEventListener("keydown", (e) => {
  initialize();
  if (e.code === "KeyK") {
    e.preventDefault();
    setOrientation(getOrientation() - 1);
  } else if (e.code === "KeyJ") {
    e.preventDefault();
    setOrientation(getOrientation() + 1);
  } else if (e.code === "ArrowUp" || e.code === "KeyW") {
    mainGridY--;
  } else if (e.code === "ArrowLeft" || e.code === "KeyA") {
    mainGridX--;
  } else if (e.code === "ArrowDown" || e.code === "KeyS") {
    mainGridY++;
  } else if (e.code === "ArrowRight" || e.code === "KeyD") {
    mainGridX++;
  }
  if (ARROW_KEYS.includes(e.code) || WASD_KEYS.includes(e.code)) {
    lastCursorX = undefined;
    lastCursorY = undefined;
    e.preventDefault();
    kickCursor();
    updatePanelPositions();
  }
  if (e.code === "Space") {
    e.preventDefault();
    mainPanelLocked = true;
    commitMove();
  }
});

const controlsInfo = document.createElement("p");
controlsInfo.style = "color:lightgray";
controlsInfo.textContent = "Controls: Mouse or WASD/Arrow keys. 'J' rotates left. 'K' rotates right. Releasing the mouse button or pressing 'Space' commits the move."
document.body.appendChild(controlsInfo);

const projectInfo = document.createElement("p");
projectInfo.style = "color:lightgray";
projectInfo.textContent = "Artemisia is open source. Check out the ";
const projectLink = document.createElement("a");
projectLink.setAttribute("href", "https://github.com/frostburn/pujo-puyo-core");
projectLink.textContent = "project page on GitHub";
projectInfo.appendChild(projectLink);
const period = document.createTextNode(".");
projectInfo.appendChild(period);
document.body.appendChild(projectInfo);

</script>
</head>
<body></body>
</html>
